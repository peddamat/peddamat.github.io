{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#hello","title":"Hello","text":"<p>Hi. I'm Sam.</p>  {{ blog_content }}"},{"location":"tags/index.html","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags/index.html#analysis","title":"analysis","text":"<ul> <li>Learning How To MitM An ATWINC1500</li> <li>MitM A Hunter Pro HC</li> <li>Understanding The ATWINC1500 Module</li> </ul>"},{"location":"tags/index.html#arduino","title":"arduino","text":"<ul> <li>ESP32</li> <li>Black Pill</li> <li>ITead Maple</li> <li>Super Blue Pill</li> </ul>"},{"location":"tags/index.html#datascience","title":"datascience","text":"<ul> <li>How To Size A Solar Battery Install</li> </ul>"},{"location":"tags/index.html#dll","title":"dll","text":"<ul> <li>Creating A DLL With Rust</li> <li>Creating A Window With Rust</li> <li>Injecting DLLs With Rust</li> <li>Production Ready DLL Injection</li> </ul>"},{"location":"tags/index.html#esp32","title":"esp32","text":"<ul> <li>ESP32</li> </ul>"},{"location":"tags/index.html#esp8266","title":"esp8266","text":"<ul> <li>Index</li> <li>ESP-01</li> <li>Wemos Mini</li> </ul>"},{"location":"tags/index.html#firmware","title":"firmware","text":"<ul> <li>Learning How To MitM An ATWINC1500</li> <li>MitM A Hunter Pro HC</li> <li>Understanding The ATWINC1500 Module</li> </ul>"},{"location":"tags/index.html#github","title":"github","text":"<ul> <li>How I Setup This Blog</li> </ul>"},{"location":"tags/index.html#howto","title":"howto","text":"<ul> <li>Creating A DLL With Rust</li> <li>Creating A Window With Rust</li> <li>Injecting DLLs With Rust</li> <li>Production Ready DLL Injection</li> </ul>"},{"location":"tags/index.html#hunter","title":"hunter","text":"<ul> <li>Taking Apart A Hunter Pro HC Controller</li> </ul>"},{"location":"tags/index.html#iot","title":"iot","text":"<ul> <li>How To Quickly Setup A Wireless MitM Proxy</li> </ul>"},{"location":"tags/index.html#irrigation","title":"irrigation","text":"<ul> <li>Taking Apart A Hunter Pro HC Controller</li> </ul>"},{"location":"tags/index.html#kali","title":"kali","text":"<ul> <li>How To Quickly Setup A Wireless MitM Proxy</li> </ul>"},{"location":"tags/index.html#microchip","title":"microchip","text":"<ul> <li>Learning How To MitM An ATWINC1500</li> <li>MitM A Hunter Pro HC</li> <li>Understanding The ATWINC1500 Module</li> </ul>"},{"location":"tags/index.html#mitm","title":"mitm","text":"<ul> <li>How To Quickly Setup A Wireless MitM Proxy</li> <li>Learning How To MitM An ATWINC1500</li> </ul>"},{"location":"tags/index.html#mkdocs","title":"mkdocs","text":"<ul> <li>Setting Up A MkDocs Plugin Development Environment</li> <li>How I Setup This Blog</li> </ul>"},{"location":"tags/index.html#obsidian","title":"obsidian","text":"<ul> <li>How I Setup This Blog</li> </ul>"},{"location":"tags/index.html#plugin","title":"plugin","text":"<ul> <li>Setting Up A MkDocs Plugin Development Environment</li> </ul>"},{"location":"tags/index.html#powertoys","title":"powertoys","text":"<ul> <li>Fancy Zones   Internals</li> <li>Fancy Zones   Overview</li> </ul>"},{"location":"tags/index.html#programming","title":"programming","text":"<ul> <li>Creating A DLL With Rust</li> <li>Creating A Window With Rust</li> <li>Injecting DLLs With Rust</li> <li>Production Ready DLL Injection</li> </ul>"},{"location":"tags/index.html#rust","title":"rust","text":"<ul> <li>Creating A DLL With Rust</li> <li>Creating A Window With Rust</li> <li>Injecting DLLs With Rust</li> <li>Production Ready DLL Injection</li> </ul>"},{"location":"tags/index.html#solar","title":"solar","text":"<ul> <li>How To Size A Solar Battery Install</li> </ul>"},{"location":"tags/index.html#sprinker","title":"sprinker","text":"<ul> <li>Taking Apart A Hunter Pro HC Controller</li> </ul>"},{"location":"tags/index.html#stm32","title":"stm32","text":"<ul> <li>Black Pill</li> <li>ITead Maple</li> <li>Super Blue Pill</li> </ul>"},{"location":"tags/index.html#teardown","title":"teardown","text":"<ul> <li>Taking Apart A Hunter Pro HC Controller</li> </ul>"},{"location":"tags/index.html#uc","title":"uC","text":"<ul> <li>Learning How To MitM An ATWINC1500</li> <li>MitM A Hunter Pro HC</li> <li>Taking Apart A Hunter Pro HC Controller</li> <li>Understanding The ATWINC1500 Module</li> </ul>"},{"location":"tags/index.html#uc_1","title":"uc","text":"<ul> <li>ESP32</li> <li>Index</li> <li>ESP-01</li> <li>Wemos Mini</li> <li>Black Pill</li> <li>ITead Maple</li> <li>Super Blue Pill</li> </ul>"},{"location":"tags/index.html#vscode","title":"vscode","text":"<ul> <li>Setting Up A MkDocs Plugin Development Environment</li> </ul>"},{"location":"tags/index.html#win32","title":"win32","text":"<ul> <li>Creating A Window With Rust</li> </ul>"},{"location":"tags/index.html#windows","title":"windows","text":"<ul> <li>Fancy Zones   Internals</li> <li>Fancy Zones   Overview</li> <li>Creating A DLL With Rust</li> <li>Creating A Window With Rust</li> <li>Injecting DLLs With Rust</li> <li>Production Ready DLL Injection</li> </ul>"},{"location":"tags/index.html#windows-rs","title":"windows-rs","text":"<ul> <li>Creating A Window With Rust</li> </ul>"},{"location":"tags/index.html#wip","title":"wip","text":"<ul> <li>Black Magic Probe</li> <li>Segger J-Link</li> <li>Adafruit Feather M0 WiFi</li> <li>Raspberry Pi</li> <li>SerialMoose Serial Port Sniffer</li> <li>My Smart Home Devices</li> <li>Samsung Refrigerator Integration</li> </ul>"},{"location":"guides/index.html","title":"Index","text":"<p>Where I show you how to do the thing.</p>"},{"location":"guides/index.html#guides","title":"Guides","text":"<p>{{ blog_content guides }}</p>"},{"location":"guides/how-to-size-a-solar-battery-install/index.html","title":"How To Size A Solar Battery Install","text":"<p>Are you considering installing solar panels on your home? While finding installers and getting quotes may be relatively straightforward, determining the need for and appropriate size for a home solar battery backup system can be a challenge. </p> <p>Last year, I was going through this process myself, and found it difficult to locate resources that could help me make an informed decision about the size of the battery bank I needed. </p> <p>In this article, I'll share my experience and provide some guidance to help you properly size your own home solar battery backup system.</p> <p>Info</p> <p>The Google Sheet used in this guide can be found here: link</p>","tags":["solar","datascience"]},{"location":"guides/how-to-size-a-solar-battery-install/index.html#getting-started","title":"Getting Started","text":"<p>In order to properly size a home solar battery backup system, it's essential to have a clear understanding of your household's energy usage patterns: </p> <ol> <li>How much energy you consume </li> <li>When you consume it</li> </ol> <p>You can usually get this information from your utility company; if not, you can explore purchasing a \"home energy monitor\" to record the data yourself.</p>","tags":["solar","datascience"]},{"location":"guides/how-to-size-a-solar-battery-install/index.html#getting-the-data-from-your-utility","title":"Getting The Data From Your Utility","text":"<p>If you're a SoCal Edison customer, you can download up to 13 months of data (in \"CSV\" and XML format) from their \"Data Sharing &amp; Download\" portal:</p> <p></p> <p>For me, a 13 month <code>.csv</code> export resulted in ~2.5Mb of data.</p>","tags":["solar","datascience"]},{"location":"guides/how-to-size-a-solar-battery-install/index.html#measure-your-own-energy-usage","title":"Measure Your Own Energy Usage","text":"<p>\"Home Energy Monitors\" are typically HAN (Home Area Network) devices, which communicates with your smart meter using ZigBee.  </p> <p>Check to see if your utility provides incentives for purchasing one.  For example, SoCal Edison offers a $25 bill credit if you buy one of their approved HAN devices.</p> <p>Personally, I use the Emporia Vue Utility Connect (Amazon Affiliate Link).</p> <p>First, because it's one of the cheaper options, but more importantly, it integrates with Home Assistant's Energy dashboard, has a decent mobile app, and provides access to raw energy usage data in CSV format.</p> <p> </p>","tags":["solar","datascience"]},{"location":"guides/how-to-size-a-solar-battery-install/index.html#data-cleanup","title":"Data Cleanup","text":"<p>Since I was in a hurry, and couldn't wait a year to collect my usage data,  I performed my analysis using the exported SoCal Edison <code>.csv</code> data.</p> <p>Here's a snippet of what it looks like:</p> <pre><code>Energy Usage Information\n\"For location: xxxxx\"\n\nMeter Reading Information\n\"Type of readings: Electricity\"\n\nSummary of Electric Power Usage Information*\n\"Your download will contain interval usage data that is currently available for your selected Service Account. Based on how our systems process and categorize usage data, your download may contain usage data of the following types: actual, estimated, validated or missing. \"\n\nDetailed Usage\n\"Start date: 2022-02-20 00:00:00\u00a0 for 393 days\"\n\n\"Data for period starting: 2022-02-20 00:00:00\u00a0 for 24 hours\"\nEnergy \u00a0Delivered time period,Usage\u00a0Delivered(Real energy in kilowatt-hours)(Real energy in kilowatt-hours),Reading quality\n\"2022-02-20 00:00:00\u00a0to 2022-02-20 00:15:00\",\"0.200\",\"\"\n\"2022-02-20 00:15:00\u00a0to 2022-02-20 00:30:00\",\"0.190\",\"\"\n...\n\"2022-02-20 23:45:00\u00a0to 2022-02-21 00:00:00\",\"0.170\",\"\"\n\n\"Data for period starting: 2022-02-20 00:00:00\u00a0 for 24 hours\"\nEnergy \u00a0Received time period,Usage\u00a0Received(Real energy in kilowatt-hours)(Real energy in kilowatt-hours),Reading quality\n\"2023-01-30 00:00:00\u00a0to 2023-01-30 00:15:00\",\"0.000\",\"\"\n...\n</code></pre> <p>As you can see, it's got a good bit of cruft, which we'll have to clean-up.</p> <p>Since my <code>sed</code> and <code>awk</code>-fu is weak, I ended up writing a Python script:</p> cleanup.py<pre><code>import re\nimport csv\n# Energy data rows look like: \"2022-02-20 00:00:00\u00a0to 2022-02-20 00:15:00\",\"0.200\",\"\"\npattern = r'\"(\\d{4}-\\d{2}-\\d{2}) (\\d{2}:\\d{2}:\\d{2}) to (\\d{4}-\\d{2}-\\d{2}) (\\d{2}:\\d{2}:\\d{2})\",\"([\\d\\.]+)\",\"\"'\nwith open('energy_usage_data.csv',encoding='utf8') as input, open('output.csv', 'w', newline='') as output:\nwriter = csv.writer(output)\nwriter.writerow([\"Start Date\", \"Start Time\", \"Start Hour\", \"End Date\", \"End Time\", \"Usage\"])\nfor row in input:\n# Replace \"non-breaking spaces\"...\nrow = row.replace(\"\\xa0\", \" \").strip()\nmatch = re.match(pattern, row)\nif match:\nstart_date, start_time, end_date, end_time, usage = match.groups()\nstart_hour = start_time.split(':')[0]\nwriter.writerow([start_date, start_time, start_hour, end_date, end_time, usage])\n</code></pre> <p>The script removes the \"non-data\" rows interspersed throughout the input file and separates out the date field <code>2022-02-20 00:15:00\u00a0to 2022-02-20 00:30:00</code> into fields that we can pivot off of in Excel.</p>","tags":["solar","datascience"]},{"location":"guides/how-to-size-a-solar-battery-install/index.html#initial-analysis","title":"Initial Analysis","text":"<p>Let's sanity check and get a feel for the data by creating a couple of quick and dirty pivot charts.</p>","tags":["solar","datascience"]},{"location":"guides/how-to-size-a-solar-battery-install/index.html#monthly-usage","title":"Monthly Usage","text":"<p>Charting the data by month helps us understand the ebbs and flows of our energy usage over the year.   </p> <p>For my dataset, there were no major insights, but it's nice to see our peak demand correlates with summer solstice, a period of peak production for solar installs.</p> <p></p>","tags":["solar","datascience"]},{"location":"guides/how-to-size-a-solar-battery-install/index.html#hourly-usage","title":"Hourly Usage","text":"<p>This simple scatterplot gives us an idea of how our energy usage is distributed across each day.</p> <p>For my household, it was interesting to learn that most of our usage occurs after 5pm, typically non-peak production hours for most any solar install.</p> <p>Taken by itself, this insight provides a pretty strong justification for investing in a battery backup system.  Let's dig a bit further to validate this hypothesis.</p> <p></p>","tags":["solar","datascience"]},{"location":"guides/how-to-size-a-solar-battery-install/index.html#advanced-analysis","title":"Advanced Analysis","text":"<p>Now that we have an inkling that a battery backup system might make sense, a few factors that need to be taken into account to determine the appropriate size. </p> <p>First, you need to calculate your daily energy consumption and the maximum amount of energy that your solar panels can produce. This will help you determine how much excess energy your system generates that can be stored in the batteries. </p> <p>Second, you need to determine the length of time that you want the backup power to last in case of a power outage. This will help you determine the amount of energy storage capacity that you need. </p>","tags":["solar","datascience"]},{"location":"guides/how-to-size-a-solar-battery-install/index.html#daily-excess-power-generated","title":"Daily Excess Power Generated","text":"<p>To create this view, we have to do a bit of estimating, specifically, we have to estimate how much energy our panels generate over whatever time period we're interested in.</p> <p></p> <p>The SoCal Edison data gives us our usage (kWh) in 15 minute increments.</p> <p>We can roughly estimate our solar install's production over the same period by taking it's \"system size\" and dividing it by 4.</p> <p>For example, a 7.1 kWh system would generate about <code>1.775 kWh</code> over that 15-minute period:</p> <p>$$  7.1 kWh / 4 = 1.775 kWh  $$ Of course, solar panels don't generate electricity 24/7, so we'll have to ballpark when our system generates power and when it doesn't.  </p> <p>In my model, I estimated that my system would generate <code>7.1 kWh</code> every hour between 12pm - 5pm, and <code>0 kWh</code> outside this window.</p> <p>Plugging this in, I'm able to estimate the \"Daily Excess Power (kWh)\" of my hypothetical solar install by subtracting the estimated \"Daily Generated Power (kWh)\" from the \"Daily Usage (kWh)\", provided by SoCal Edison:</p> <p>$$ DailyExcessPower (kWh) = DailyGeneratedPower (kWh) - DailyUsage (kWh) $$</p>","tags":["solar","datascience"]},{"location":"guides/how-to-size-a-solar-battery-install/index.html#daily-total-battery-usage","title":"Daily Total battery Usage","text":"<p>Now that we've estimated how much excess capacity our system generates, we know how much capacity our battery system could potentially capture.</p> <p></p>","tags":["solar","datascience"]},{"location":"guides/how-to-size-a-solar-battery-install/index.html#conclusions","title":"Conclusions","text":"<p>After reviewing my data,  </p> <code>#solar</code> <code>#datascience</code>","tags":["solar","datascience"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html","title":"Setting Up A MkDocs Plugin Development Environment","text":"<p>As mentioned in How I Setup This Blog, MkDocs is a core part of this blog's publishing workflow.  I also mentioned that I've debugged a plugin or two, and written custom plugins, to  fit the workflow to my liking.</p> <p>This post will walk you through my development workflow.</p>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#debugging-a-plugin","title":"Debugging A Plugin","text":"<p>One plugin that does major lifting is the <code>mkdocs-roamlinks</code> plugin, which resolves and converts internal links, including <code>[[wikilink]]</code>-style links popular among Obsidian users.</p> <p>However, I found myself with a persnickety issue when linking files with parenthesis in their filenames, for example,  <code>Let's Write An Article (Part 1).md</code> or <code>Let's Write An Article (Part 2).md</code>.  </p> <p>The resulting links were came out like <code>Let's Write An Article (Part 1))</code>, a subtle error, but an error nonetheless.</p> <p>So I did the right thing, and submitted a pull request: here</p> <p>In this article, I'll walk you through how I went about debugging that issue.</p>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#development-environment-setup","title":"Development Environment Setup","text":"<p>I use VSCode on Windows 10 for 95% of my development work.  However, I can't live without a Unix shell, so I almost always work out of a Windows Subsystem for Linux (WSL) environment.</p> <p>I first do a <code>git clone</code> of my MkDocs repository from a WSL prompt:</p> <pre><code>me in ~\n[I] \u276f git clone https://github.com/peddamat/mkdocs-obsidian.git\nCloning into 'mk'...\nremote: Enumerating objects: 817, done.\nremote: Counting objects: 100% (284/284), done.\nremote: Compressing objects: 100% (120/120), done.\nremote: Total 817 (delta 127), reused 276 (delta 125), pack-reused 533\nReceiving objects: 100% (817/817), 686.36 KiB | 2.29 MiB/s, done.\nResolving deltas: 100% (420/420), done.\n</code></pre> <p>I then fire up a VSCode instance DIRECTLY FROM THE WSL PROMPT!</p> <pre><code>me in ~\n[I] \u276f cd mkdocs-obsidian\n[I] \u276f code .\nme in mkdocs-obsidian on \ue0a0 main took 2s\n</code></pre> <p>VSCode starts up in this nifty \"WSL\" mode, making interaction with the WSL environment completely seamless:</p> <p></p>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#pulling-my-obsidian-vault","title":"Pulling My Obsidian Vault","text":"<p>I store my Obsidian vault in a separate private repository.  The reason I set it up this way was to allow me to share my <code>mkdocs-obisidian</code> repo.</p> <pre><code>[I] \u276f git clone git@github.com:peddamat/notes.git\nCloning into 'notes'...\nremote: Enumerating objects: 1521, done.\nremote: Counting objects: 100% (276/276), done.\nremote: Compressing objects: 100% (183/183), done.\nremote: Total 1521 (delta 171), reused 194 (delta 91), pack-reused 1245\nReceiving objects: 100% (1521/1521), 37.05 MiB | 15.31 MiB/s, done.\nResolving deltas: 100% (698/698), done.\nme in mkdocs-obsidian on \ue0a0 main took 4s\n</code></pre>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#local-webserver-setup","title":"Local Webserver Setup","text":"<p>Now, from a VSCode terminal, I can fire up a local development instance of my blog using:</p> <pre><code>[I] \u276f pipenv install\nInstalling dependencies from Pipfile.lock (43fcfc)\u2026\n  \ud83d\udc0d   \u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589 57/57 \u2014 00:00:18\nTo activate this project's virtualenv, run the following:\n $ pipenv shell\nme in mkdocs-obsidian on \ue0a0 main took 20s \n[I] \u276f pipenv run mkdocs serve\n...\nINFO     -  Documentation built in 3.84 seconds\nINFO     -  [21:37:00] Watching paths for changes: 'notes', 'mkdocs.yml',\n            'overrides/custom-blog.html'\nINFO     -  [21:37:00] Serving on http://127.0.0.1:8000/\n</code></pre> <p>Making my blog accessible at http://127.0.0.1:8000/ while I work on it.</p> <p></p> <p>At this point I'm ready to start developing.</p>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#getting-the-code","title":"Getting The Code","text":"<p>In this example, <code>mkdocs-roamlinks-plugin</code> is already locked and loaded into <code>mkdocs-obsidian</code>, using <code>pipenv install mkdocs-roamlinks-plugin</code>.</p> <p>So we'll need to <code>git clone</code> a local copy of the code to work on:</p> <pre><code>[I] \u276f git clone git@github.com:peddamat/mkdocs-roamlinks-plugin.git\nCloning into 'mkdocs-roamlinks-plugin'...\nremote: Enumerating objects: 101, done.\nremote: Counting objects: 100% (57/57), done.\nremote: Compressing objects: 100% (31/31), done.\nremote: Total 101 (delta 33), reused 43 (delta 26), pack-reused 44\nReceiving objects: 100% (101/101), 19.70 KiB | 3.94 MiB/s, done.\nResolving deltas: 100% (47/47), done.\nme in mkdocs-obsidian on \ue0a0 main [?] took 2s\n</code></pre> <p>If you'll notice, I'm pulling the code from my own personal fork of <code>mkdocs-roamlinks-plugin</code>.  It's good practice to always fork a repo before you <code>git clone</code> it.  (Simply so you can avoid having to Google the syntax for removing and adding a remote in git)</p>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#configuring-pipenv","title":"Configuring Pipenv","text":"<p>Now that you've got a local copy of the plugin code:</p> <p></p> <p>We need to tell <code>pipenv</code> to install this local copy of the plugin code, rather than what it previously installed into the <code>packages</code> folder.</p> <p>This is done by using the <code>-e</code> flag (Note: the <code>-e</code> flag also works with plain <code>pip install</code>):</p> <pre><code>[I] \u276f pipenv install -e mkdocs-roamlinks-plugin\nInstalling -e mkdocs-roamlinks-plugin\u2026\nLooking in indexes: https://pypi.python.org/simple\nObtaining file:///home/me/mkdocs-obsidian/mkdocs-roamlinks-plugin\n...\nInstalling collected packages: mkdocs-roamlinks-plugin\n  Attempting uninstall: mkdocs-roamlinks-plugin\n    Found existing installation: mkdocs-roamlinks-plugin 0.2.0\n    Uninstalling mkdocs-roamlinks-plugin-0.2.0:\n      Successfully uninstalled mkdocs-roamlinks-plugin-0.2.0\n  Running setup.py develop for mkdocs-roamlinks-plugin\nSuccessfully installed mkdocs-roamlinks-plugin\n\nAdding -e mkdocs-roamlinks-plugin to Pipfile's [packages]\u2026\nPipfile.lock (43fcfc) out of date, updating to (e1b7fa)\u2026\nLocking [dev-packages] dependencies\u2026\nLocking [packages] dependencies\u2026\nUpdated Pipfile.lock (e1b7fa)!\nInstalling dependencies from Pipfile.lock (e1b7fa)\u2026\n  \ud83d\udc0d   \u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589 58/58 \u2014 00:00:27\nme in mkdocs-obsidian on \ue0a0 main [!?] took 52s\n</code></pre> <p>Now you have everything you need to start hacking on the plugin.</p> <p>One thing to note, however, <code>mkdocs serve</code> does not automatically refresh the site as you make changes to the plugin's code.  You will need to kill and rerun <code>mkdocs serve</code> as you work.</p>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#alternatively","title":"Alternatively...","text":"<p>If you prefer discipline over speed, you can forgo making a local clone of your plugin, and simply work directly from your GitHub fork.</p> <p>You do this by:</p> <pre><code>[I] \u276f pipenv install git+https://github.com/peddamat/mkdocs-roamlinks-plugin@master\n\nInstalling git+https://github.com/peddamat/mkdocs-roamlinks-plugin@master\u2026\n\u280fWARNING: pipenv requires an #egg fragment for version controlled dependencies. Please install remote dependency in the form git+https://github.com/peddamat/mkdocs-roamlinks-plugin#egg=&lt;package-name&gt;.\n</code></pre> <p>Oops, I forgot the part about the <code>#egg=&lt;package-name&gt;</code>, as will you.</p> <p>You can find the <code>&lt;package-name&gt;</code> bit in the plugin's <code>setup.py</code>:</p> setup.py<pre><code>from setuptools import setup, find_packages\nsetup(\nname='mkdocs-roamlinks-plugin',\n...\nentry_points={\n'mkdocs.plugins': [\n'roamlinks = mkdocs_roamlinks_plugin.plugin:RoamLinksPlugin',\n]\n}\n)\n</code></pre> <p>It will be the bit at the end there. </p> <p>Anyways, add that and:</p> <pre><code>[I] \u276f pipenv install git+https://github.com/peddamat/mkdocs-roamlinks-plugin@master#egg=RoamLinksPlugin\nInstalling git+https://github.com/peddamat/mkdocs-roamlinks-plugin@master#egg=RoamLinksPlugin\u2026\n\u2819Warning: You installed a VCS dependency in non\u2013editable mode. This will work fine, but sub-dependencies will not be resolved by $ pipenv lock.\n  To enable this sub\u2013dependency functionality, specify that this dependency is editable.\nLooking in indexes: https://pypi.python.org/simple\nCollecting RoamLinksPlugin\n  Cloning https://github.com/peddamat/mkdocs-roamlinks-plugin (to revision master) to /tmp/pip-install-tmytxsvo/RoamLinksPlugin\n...\nBuilding wheels for collected packages: mkdocs-roamlinks-plugin, mkdocs-roamlinks-plugin\n  Building wheel for mkdocs-roamlinks-plugin (setup.py): started\n  Building wheel for mkdocs-roamlinks-plugin (setup.py): finished with status 'done'\nCreated wheel for mkdocs-roamlinks-plugin: filename=mkdocs_roamlinks_plugin-0.2.0-py3-none-any.whl size=5000 sha256=54562b59cb08d33050dc798f20af767b179d3fbbe431f47100fb71cfd2fa661b\n  Stored in directory: /tmp/pip-ephem-wheel-cache-3go_fqjk/wheels/db/eb/02/34dd609165555dbc911de65c19533bc9fc01f05b99bafef267\n  Building wheel for mkdocs-roamlinks-plugin (setup.py): started\n  Building wheel for mkdocs-roamlinks-plugin (setup.py): finished with status 'done'\nCreated wheel for mkdocs-roamlinks-plugin: filename=mkdocs_roamlinks_plugin-0.2.0-py3-none-any.whl size=5000 sha256=54562b59cb08d33050dc798f20af767b179d3fbbe431f47100fb71cfd2fa661b\n  Stored in directory: /tmp/pip-ephem-wheel-cache-3go_fqjk/wheels/09/48/26/db3e2583dc622b5b0abf779173bd857e464b75bc67a5f03a4f\nSuccessfully built mkdocs-roamlinks-plugin mkdocs-roamlinks-plugin\n\nAdding git+https://github.com/peddamat/mkdocs-roamlinks-plugin@master#egg=RoamLinksPlugin to Pipfile's [packages]\u2026\nPipfile.lock (bdb602) out of date, updating to (31e69d)\u2026\nLocking [dev-packages] dependencies\u2026\nLocking [packages] dependencies\u2026\nUpdated Pipfile.lock (31e69d)!\nInstalling dependencies from Pipfile.lock (31e69d)\u2026\n  \ud83d\udc0d   \u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589 57/57 \u2014 00:00:18\nTo activate this project's virtualenv, run the following:\n $ pipenv shell\nme in mkdocs-obsidian on \ue0a0 main [!?] took 37s </code></pre> <p>Now, after committing and pushing your code to GitHub, you can do a <code>pipenv update</code> which will pull and install your latest commits:</p> <pre><code>$ pipenv update                           Running $ pipenv lock then $ pipenv sync.\nLocking [dev-packages] dependencies\u2026\nLocking [packages] dependencies\u2026\nUpdated Pipfile.lock (43fcfc)!\nInstalling dependencies from Pipfile.lock (43fcfc)\u2026\n  \ud83d\udc0d   \u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589 57/57 \u2014 00:00:22\nTo activate this project's virtualenv, run the following:\n $ pipenv shell\nAll dependencies are now up-to-date!\n</code></pre>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#writing-a-plugin","title":"Writing A Plugin","text":"<p>MkDocs provides two different ways to extend its core functionality: hooks and plugins, with hooks being a lightweight version of plugins.</p> <p>Unless you want to redistribute your extension, my advice is to simply write a hook.  Or, start your plugin as a hook until it's ready to be repackaged.</p>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#getting-started","title":"Getting Started","text":"<p>If you're a \"first principles\" sort of person (guilty), the best place to start learning the codebase is from <code>mkdocs/mkdocs/commands</code>.  </p> <p>This is where the MkDocs command-line commands are defined, i.e. <code>mkdocs build</code> &amp; <code>mkdocs serve</code>.  The code for the former being defined in <code>build.py</code> and for the latter in <code>serve.py</code>.</p> <ul> <li>mkdocs/structure/files.py#L303 is where File objects are instantiated. </li> <li>mkdocs/commands/build.py#L297 is where the <code>on_files</code> event gets called.</li> <li>mkdocs/commands/build.py#L239 is where the page is written using the <code>abs_dest_path</code> property of the file.</li> <li>mkdocs/structure/pages.py#L326 - Documentation file xxx which is not found in the documentation files.</li> </ul> <p>Once you get a feel for how things are put together, the next best place to visit is the plugin reference, specifically, the Events section, which provides this great diagram illustrating the basic execution flow:  </p> <p></p> <p>MkDocs-Material has a customization section: https://squidfunk.github.io/mkdocs-material/customization/</p> <p>MkDocs plugin repository: https://www.wheelodex.org/entry-points/mkdocs.plugins/</p> <p>Creating a article list for <code>index.html</code>: <pre><code>{% extends \"base.html\" %}\n\n{% block content %}\n\n    {{ page.content }}\n\n&lt;nav class=\"{{ class }}\" aria-label=\"{{ lang.t('nav') }}\" data-md-level=\"0\"&gt;\n&lt;ul class=\"md-nav__list\" data-md-scrollfix&gt;\n            {% for nav_item in nav %}\n            {% set path = \"__nav_\" ~ loop.index %}\n            {% set level = 1 %}\n            {% include \"partials/nav-item.html\" %}\n            {% endfor %}\n        &lt;/ul&gt;\n&lt;/nav&gt;\n{% endblock %}\n</code></pre></p> <ul> <li></li> </ul>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#forking-mkdocs","title":"Forking MkDocs","text":"","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#how-to-specify-a-github-repo-in-requirementstxt","title":"How to specify a GitHub repo in requirements.txt","text":"<ul> <li> <p>Specify commit hash (41b95ec in the context of updated requirements.txt): <pre><code>package-one==1.9.4\ngit+https://github.com/path/to/package-two@41b95ec#egg=package-two\npackage-three==1.0.1\n</code></pre></p> </li> <li> <p>Specify branch name (master): <pre><code>git+https://github.com/path/to/package-two@master#egg=package-two\n</code></pre></p> </li> <li> <p>Specify tag (0.1): <pre><code>git+https://github.com/path/to/package-two@0.1#egg=package-two\n</code></pre></p> </li> <li> <p>Specify release (3.7.1): <pre><code>git+https://github.com/path/to/package-two@releases/tag/v3.7.1#egg=package-two\n</code></pre></p> </li> </ul> <p>Note that <code>#egg=package-two</code> is not a comment here, it is to explicitly state the package name - source</p>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#debugging","title":"Debugging","text":"<p>The first issue I had was that my image links weren't resolving correctly.  This means images looked like this:</p> <pre><code>![[notepad-1.png]]\n</code></pre> <p>By default, Obsidian uses \"wikistyle\" links, which differ from Markdown links.</p> <p>The MkDocs plugin <code>roamlinks</code> converts wikistyle links, but apparently something was broken.</p> <p>Taking a look at the GitHub Actions dashboard:</p> <p></p> <p>Looking at the source:</p> <p>```python</p>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/debugging-a-mkdocs-plugin/index.html#walk-through-all-files-in-docs-directory-to-find-a-matching-file","title":"Walk through all files in docs directory to find a matching file","text":"<p>if filename:     if '/' in filename:         if 'http' in filename: # http or https             rel_link_url = filename         else:             rel_file = filename             if not '.' in filename:   # don't have extension type                 rel_file = filename + \".md\"</p> <pre><code>        abs_link_url = os.path.dirname(os.path.join(\n            self.base_docs_url, rel_file))\n        # Constructing relative path from the linker to the link\n        rel_link_url = os.path.join(\n                os.path.relpath(abs_link_url, abs_linker_url), os.path.basename(rel_file))\n        if title:\n            rel_link_url = rel_link_url + '#' + format_title\nelse:\n    for root, dirs, files in os.walk(self.base_docs_url):\n        for name in files:\n            # If we have a match, create the relative path from linker to the link\n            if self.simplify(name) == self.simplify(filename):\n                # Absolute path to the file we want to link to\n                abs_link_url = os.path.dirname(os.path.join(\n                    root, name))\n                # Constructing relative path from the linker to the link\n                rel_link_url = os.path.join(\n                        os.path.relpath(abs_link_url, abs_linker_url), name)\n                if title:\n                    rel_link_url = rel_link_url + '#' + format_title\nif rel_link_url == '':\n    log.warning(f\"RoamLinksPlugin unable to find {filename} in directory {self.base_docs_url}\")\n    return whole_link\n</code></pre> <p>else:     rel_link_url = '#' + format_title     ```</p> <p></p> <code>#mkdocs</code> <code>#plugin</code> <code>#vscode</code>","tags":["mkdocs","plugin","vscode"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html","title":"How I Setup This Blog","text":"<p>I recently migrated my, uh... pkm \"system\" from a Joplin and OneNote mashup to one centered solely around Obsidian. </p> <p>See, months ago I read about Zettelkasten, which began my foray into the world of roam-likes, starting with logseq and ending with Obsidian.</p> <p>What actually hooked me was the maturity of its vim bindings - Joplin\u2019s are great, logseq\u2019s feel clunky.</p>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#10000-ft-view","title":"10000-ft View","text":"<p>I write notes in Obsidian.  When I hit save, my changes are pushed to GitHub, which rebuilds and redeploys my site.  </p> <p>It looks something like this:</p> <p></p> <ul> <li>Write notes in Obsidian</li> <li>Store notes on GitHub</li> <li>Convert notes to HTML with MkDocs</li> <li>GitHub Pages used for hosting</li> </ul>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#obsidian-git","title":"Obsidian Git","text":"<p>Here is my Obsidian setup: the key component being Obsidian Git:</p> <p></p> <p>'Hitting save' entails a <code>git commit</code> using:</p> <p></p> <p>Followed by <code>git push</code> using:</p> <p></p> <p>Obsidian Git auto-generates a commit message, so the above is all it takes for me to deploy.</p>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#mkdocs","title":"MkDocs","text":"<p>MkDocs is a static-site generator: it converts Markdown (<code>.md</code>) files into <code>.html</code>, similar to Jekyll and Hugo.</p> <p>MkDocs-Material is an MkDocs distribution which comes with a pretty theme and a number of compelling extensions which make your site look and feel modern: see here</p>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#customization","title":"Customization","text":"<p>mkdocs-obsidian my customized MkDocs-Material configuration, based off mr-karan's repository.</p> <p>I wrote code to scratch itches, adding:</p> <ul> <li>A way to deploy only \"Published\" notes, keeping \"Drafts\" private</li> <li>A way to \"slugify\" filenames so my URLs would be SEO-friendly</li> <li>Fixes for buggy \"<code>[[wikistyle]]</code>\" link rendering</li> </ul>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#hooks","title":"Hooks","text":"","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#only_include_publishedpy","title":"only_include_published.py","text":"<p>In lieu of using separate Obsidian vaults, or segregating my notes by subfolder, I prefer to distinguish \"Published\" notes from drafts through frontmatter metadata.  </p> <p>Specifically, by denoting \"Published\" notes as those that have the <code>publish</code> key set to <code>true</code>, which looks like:</p> <pre><code>---\npublish: true\n---\n</code></pre> <p>This simple MkDocs hook triggers when <code>on_files</code> fires, reading each note and filtering for notes with frontmatter containing <code>publish: true</code>.</p> <pre><code>import os, logging, typing, frontmatter\nfrom typing import Optional\nimport mkdocs.plugins\nfrom mkdocs.structure.pages import Page\nfrom mkdocs.structure.files import Files\nfrom mkdocs.config.defaults import MkDocsConfig\nlog = logging.getLogger('mkdocs')\ndef is_page_published(meta: typing.Dict) -&gt; bool:\nif 'publish' in meta:\nreturn meta['publish'] == True\ndef on_files(files: Files, *, config: MkDocsConfig) -&gt; Optional[Files]:\nbase_docs_url = config[\"docs_dir\"]\nfor file in files.documentation_pages():\nabs_path = os.path.join(base_docs_url, file.src_uri)\nwith open(abs_path, 'r') as raw_file:\ntry:\nmetadata = frontmatter.load(raw_file).metadata\nif is_page_published(metadata):\nlog.info(f\"Adding published document {file.src_uri}\")\nelse:\nfiles.remove(file)\nexcept:\nlog.error(f\"Found malformed frontmatter in {file.src_uri}!\")\nreturn files\ndef on_post_page(output: str, *, page: Page, config: MkDocsConfig) -&gt; Optional[str]:\nif not is_page_published(page.meta):\nreturn ''\nreturn output\n</code></pre>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#flatten_filenamespy","title":"flatten_filenames.py","text":"<p>This is even simpler MkDocs hook triggers when <code>on_files</code> fires, converting filenames such as <code>How To Write A Dll In Rust (part 1).md</code> to <code>how-to-write-a-dll-in-rust-part-1.md</code>.</p> <pre><code>import logging, re\nimport mkdocs.plugins\nlog = logging.getLogger('mkdocs')\n# Rewrite using `python-slugify`\ndef on_files(files, config):\nfor f in files:\nif f.is_documentation_page() or f.is_media_file():\nf.abs_dest_path = f.abs_dest_path.replace(\" \", \"-\").lower()\nf.abs_dest_path = f.abs_dest_path.replace(\"(\", \"\").lower()\nf.abs_dest_path = f.abs_dest_path.replace(\")\", \"\").lower()\nf.dest_path = f.dest_path.replace(\" \", \"-\").lower()\nf.dest_path = f.dest_path.replace(\"(\", \"\").lower()\nf.dest_path = f.dest_path.replace(\")\", \"\").lower()\nf.url = f.dest_path.replace(\"%20\", \"-\").lower()\nreturn files\n</code></pre>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#plugins","title":"Plugins","text":"<p>mkdocs-obsidian includes these third-party plugins:</p> <ul> <li>mkdocs-roamlinks-plugin: converts  <code>[[wikilinks]]</code> links to proper website links</li> <li>mkdocs-blogging-plugin: generates homepage article list</li> <li>mkdocs-git-revision-date-plugin: adds \"Last updated\" footer tags </li> </ul>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#github","title":"GitHub","text":"<p>My setup uses three repositories:</p> <ol> <li>notes is a private repo containing my \"Obsidian vault\" (folder containing <code>.md</code> files)</li> <li>mkdocs-obsidian is a public repo containing my MkDocs configuration (mkdocs.yml)</li> <li>peddamat.github.io is a public repo containing static <code>.html</code> files</li> </ol> <p>When changes are pushed to the <code>notes</code> repository, the <code>mkdocs-obsidian</code> repository rebuilds all \"Published\" notes and pushes the results to the <code>peddamat.github.io</code> repository.</p> <p>This is all orchestrated using GitHub Action workflows, one in the <code>notes</code> repository and one in the <code>mkdocs-obsidian</code> repository, which we'll discuss below.</p>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#repositories","title":"Repositories","text":"","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#notes-repository","title":"<code>notes</code> repository","text":"<p>This is a private repository containing my Obsidian vault:</p> <pre><code>$ tree\n.\n\u251c\u2500\u2500 .github\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 workflows\n|   \u2502\u00a0\u00a0 \u2514\u2500\u2500 main.yml # (1)\n\u251c\u2500\u2500 .obsidian\n\u251c\u2500\u2500 index.md\n\u251c\u2500\u2500 Coding\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Creating A DLL With Rust.md\n...\n\u251c\u2500\u2500 Dotfiles\n...\n\u251c\u2500\u2500 assets\n\u251c\u2500\u2500 img\n\u251c\u2500\u2500 resources\n\u251c\u2500\u2500 stylesheets\n\u2514\u2500\u2500 tags.md\n</code></pre>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#github-workflow","title":"GitHub Workflow","text":"<p>The GitHub Action workflow is defined in <code>.github/workflows/main.yml</code>.  </p> <pre><code>name: Trigger Deployment\non:\npush:\nbranches:\n- main\nenv:\nUSER: peddamat\nREPO: mkdocs-obsidian\njobs:\nbuild:\nruns-on: ubuntu-latest\nsteps:\n# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it\n- name: Trigger Build and Deploy\nrun: |\ncurl -X POST https://api.github.com/repos/$USER/$REPO/dispatches \\\n-H 'Accept: application/vnd.github.everest-preview+json' \\\n-u ${{ secrets.API_TOKEN_GITHUB }} \\\n--data '{\"event_type\": \"Trigger Workflow\", \"client_payload\": { \"repository\": \"'\"$GITHUB_REPOSITORY\"'\" }}'\n- uses: actions/checkout@v3\n</code></pre> <p>The \"Trigger Deployment\" workflow, runs after commits are pushed to <code>main</code> branch of the <code>notes</code> repo,  its sole purpose being to  triggers the \"Build and Deploy Site\" workflow in the <code>mkdocs-obsidian</code> repository.</p>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#mkdocs-obsidian-repository","title":"<code>mkdocs-obsidian</code> repository","text":"<p>This is a public repository containing my fork of mr-karan/notes:</p> <pre><code>$ tree -L 1 -a\n.\n\u251c\u2500\u2500 .github\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 workflows\n|   \u2502\u00a0\u00a0 \u2514\u2500\u2500 main.yml\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 hooks\n\u251c\u2500\u2500 overrides\n\u251c\u2500\u2500 Pipfile\n...\n</code></pre>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#github-workflow_1","title":"GitHub Workflow","text":"<pre><code>name: Build and Deploy Site\non:\nrepository_dispatch:\npush:\nbranches:\n- main\njobs:\ndeploy:\nruns-on: ubuntu-latest\nsteps:\n- name: Checkout mkdocs-obsidian repo\nuses: actions/checkout@v3\n- name: Checkout notes repo into ./notes\nuses: actions/checkout@v3\nwith:\ntoken:  ${{ secrets.PULL_NOTES }}\nrepository: peddamat/notes\npath: notes\n- name: Setup Python\nuses: actions/setup-python@v4\nwith:\npython-version: '3.8'\n- name: Upgrade pip\nrun: |\n# install pip=&gt;20.1 to use \"pip cache dir\"\npython3 -m pip install --upgrade pip\n- name: Get pip cache dir\nid: pip-cache\nrun: echo \"::set-output name=dir::$(pip cache dir)\"\n- name: Cache dependencies\nuses: actions/cache@v2\nwith:\npath: ${{ steps.pip-cache.outputs.dir }}\nkey: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\nrestore-keys: |\n${{ runner.os }}-pip-\n- name: Install dependencies\nrun: python3 -m pip install -r ./requirements.txt\n- run: mkdocs build\n- name: Deploy\nuses: peaceiris/actions-gh-pages@v3\nwith:\npersonal_token: ${{ secrets.PULL_NOTES }}\nexternal_repository: peddamat/peddamat.github.io\npublish_branch: main  # default: gh-pages\npublish_dir: ./site\ncname: samrambles.com\n</code></pre>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#peddamatgithubio-repository","title":"<code>peddamat.github.io</code> repository","text":"<p>This is a public repository containing the output of MkDocs, a static <code>.html</code> render of my <code>.md</code> notes.</p>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#github-pages","title":"GitHub Pages","text":"<p>GitHub Pages provides free top-level domain hosting for one site, with the stipulation being the site must be hosted in a repository named: username.github.io, where username is your GitHub username.</p> <p>Meaning, my free website, <code>peddamat.github.io</code>, is served up from my peddamat.github.io repository, which is configured like this:</p> <p></p>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#github-workflow_2","title":"GitHub Workflow","text":"","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#permissions","title":"Permissions","text":"<p>My <code>notes</code> and <code>mkdocs-obsidian</code> repositories need the following workflow permissions, found under \"Settings / Actions / General\" in each repository:</p> <p></p>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#personal-access-token-pat","title":"Personal Access Token (PAT)","text":"<p>Personal access tokens function like ordinary OAuth access tokens. They can be used instead of a password for Git over HTTPS, or can be used to authenticate to the API over Basic Authentication. </p> <p>The workflows used by the <code>notes</code> and <code>mkdocs-obsidian</code> repositories utilize PATs to allow inter-repository interaction, for example, allowing the <code>notes</code> repository to trigger workflows in the <code>mkdocs-obsidian</code> repository.</p> <p>To generate a PAT, click \"Generate new token (classic)\" on https://github.com/settings/tokens:</p> <p></p> <p>And select the following scopes:</p> <p></p>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#repository-secret","title":"Repository Secret","text":"<p>\"Repository Secrets\" enable passwords/tokens to be used by workflows without requiring them to be publically visible in workflow <code>.yaml</code>.</p> <p>Both the \"Trigger Deployment\" and \"Build and Deploy Site\" workflows use a secret named <code>secrets.API_TOKEN_GITHUB</code>, contains a \"GitHub Personal Access Token (PAT)\", configured as described in the Personal Access Token (PAT) section.</p> <p>Create the <code>secret.API_TOKEN_GITHUB</code> secret in each repository's \"Settings / Secrets and variables / Actions\" section:</p> <p></p> <p>Hit 'New repository secret':</p> <p></p> <p>And paste the PAT from Step 1.</p>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#mkdocs-development-setup","title":"MkDocs Development Setup","text":"<p>To work on the MkDocs code, I use WSL2 running Ubuntu under Windows 10, with VSCode as my editor.</p> <p>Setting up an development environment consists of the following steps:</p> <ul> <li>Clone <code>mkdocs-obsidian</code> repo</li> <li>Clone <code>notes</code> repo</li> <li>Install dependencies</li> <li>Start staging server</li> </ul> <p>Which translates to:</p> <pre><code>git clone git@github.com:peddamat/mkdocs-obsidian.git samrambles.com\ncd samrambles.com\ngit clone git@github.com:peddamat/notes.git notes\npipenv shell\npipenv install\nmake serve\n</code></pre> <p>And looks like:</p> <p></p>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#adding-mkdocs-plugins","title":"Adding MkDocs Plugins","text":"<p>MkDocs plugins are generally distributed as Python PyPi packages, installed using <code>pip</code>, for example:</p> <p>Installing the <code>mkdocs-git-revision-date-plugin</code>:</p> <pre><code>pip install mkdocs-git-revision-date-plugin\n</code></pre> <p>Since I am using <code>pipenv</code>, this would look like:</p> <pre><code>pipenv install mkdocs-git-revision-date-plugin\n</code></pre>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-i-setup-this-blog/index.html#deploying-directly","title":"Deploying Directly","text":"<p>Sometimes GitHub shits the bed, when that happens, I can manually deploy to <code>peddamat.github.io</code> using:</p> <pre><code>$ mkdocs gh-deploy --force --remote-branch main --remote-name https://peddamat:&lt;personal-access-token&gt;@github.com/peddamat/peddamat.github.io.git\n</code></pre> <p></p> <p></p> <code>#obsidian</code> <code>#mkdocs</code> <code>#github</code>","tags":["obsidian","mkdocs","github"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html","title":"How To Quickly Setup A Wireless MitM Proxy","text":"<p>While working on the Taking Apart A Hunter Pro-HC Controller project, I needed to setup a wireless MitM proxy as part of my test rig.</p> <p>Here's the fastest way I found to get one up and running, and it works on both Windows and Mac.</p>","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#requirements","title":"Requirements","text":"<ul> <li>VMWare Fusion (Mac) or VMWare Player (PC)</li> <li>Kali Linux VMWare image</li> <li>USB WiFi Dongle (i.e. Edimax EW-7811un)     ![[41m+ZoNoWqL.AC_UF894,1000_QL80.jpg|Edimax EW-7811un 802.11n WiFi Adapter|200]]</li> </ul>","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#download-kali-image","title":"Download Kali Image","text":"<p>Kali Linux is available as pre-built VMs: here</p> <p></p> <p>Download the \"VMWare 64\" package, which comes an ~3GB <code>.7z</code> file.</p> <p></p>","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#vmware-fusion","title":"VMWare Fusion","text":"","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#install-vmware-fusion-mac","title":"Install VMWare Fusion (Mac)","text":"<p>VMWare Fusion is available for free under a Personal Use license: here</p>","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#configure-wifi-adapter","title":"Configure WiFi Adapter","text":"","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#launch-kali-linux-vm","title":"Launch Kali Linux VM","text":"<p>Double-click on the <code>.vmwarevm</code> file, which will launch VMWare Fusion:  </p> <p></p> <p>Log into the desktop using the username and password:  <code>kali</code> / <code>kali</code>:</p> <p></p> <p>Launch a terminal window:</p> <p></p>","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#vmware-player","title":"VMWare Player","text":"","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#install-vmware-player-pc","title":"Install VMWare Player (PC)","text":"","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#configure-wifi-adapter_1","title":"Configure WiFi Adapter","text":"","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#launch-kali-linux-vm_1","title":"Launch Kali Linux VM","text":"","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#start-bridged-mitm-proxy","title":"Start Bridged MitM Proxy","text":"<p>mitm setup using hostapd in kali</p> <p>setup-mitm-bridged.sh</p> setup-mitm-bridged.sh<pre><code>#!/bin/bash\n# Based on: https://mirzafahad.github.io/2021-03-07-wifi-rouge-access-point-part3/\nsudo apt-get update &amp;&amp; sudo apt-get install hostapd bridge-utils\n\nmkdir conf\n\ncat &gt; conf/wifi_ap.config &lt;&lt;EOF\ninterface=wlan0\nbridge=br0\ndriver=nl80211\nhw_mode=g\nssid=WifiTest\nchannel=1\nEOF\nsudo brctl addbr br0\nsudo brctl addif br0 eth0\nsudo ifconfig br0 up\nbrctl show\nsudo /etc/init.d/networking stop\nsudo ifconfig eth0 down\nsudo ifconfig wlan0 down\nsudo ifconfig br0 up\nsudo ifconfig eth0 up\nsudo hostapd -d conf/wifi_ap.config\n</code></pre>","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#start-transparent-mitm-proxy","title":"Start Transparent MitM Proxy","text":"<p>mitm setup using hostapd and mitmproxy (--transparent) in kali</p> <p>setup-mitm-transparent.sh</p> setup-mitm-transparent.sh<pre><code>#!/bin/bash\n# Based on: https://bumper.readthedocs.io/en/latest/Sniffing/\nmkdir -p conf logs\n\ncat &gt; conf/dnsmasq.conf &lt;&lt;EOF\ninterface=wlan0\ndhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h\ndhcp-option=3,192.168.1.1\ndhcp-option=6,192.168.1.1\nserver=8.8.8.8\nlog-queries\nlog-dhcp\nlisten-address=127.0.0.1\n# Set DNS settings per Bumper documentation as needed below\n#address=/msg-na.ecouser.net/192.168.1.1\n#address=/mq-ww.ecouser.net/192.168.1.1\nEOF\ncat &gt; conf/hostapd.conf &lt;&lt;EOF\ninterface=wlan0\ndriver=nl80211\nssid=bumper_mitm\nhw_mode=g\nchannel=11\nmacaddr_acl=0\nignore_broadcast_ssid=0\nauth_algs=1\nwpa=2\nwpa_passphrase=IAmNotSafe\nwpa_key_mgmt=WPA-PSK\nwpa_pairwise=CCMP\nwpa_group_rekey=86400\nieee80211n=1\nwme_enabled=1\nEOF\nsudo apt-get update\nsudo apt-get install gnome-terminal hostapd\n\nsysctl -w net.ipv4.ip_forward=1\nsysctl -w net.ipv4.conf.all.send_redirects=0\niptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 80 -j REDIRECT --to-port 8080\niptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 443 -j REDIRECT --to-port 8080\niptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 8883 -j REDIRECT --to-port 8080\nsudo nmcli radio wifi off\nsudo rfkill unblock wlan\nifconfig wlan0 up 192.168.1.1 netmask 255.255.255.0\nroute add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1\n\n#Open in new tabs\ngnome-terminal -x sh -c \"SSLKEYLOGFILE=\"logs/sslmitmkeylog.txt\" mitmweb -m transparent -w \"logs/mitmout_new.txt\" --tcp-hosts 192.168.1.\\d+ --ssl-insecure --raw; bash\"\ngnome-terminal -x sh -c \"dnsmasq -C conf/dnsmasq.conf -d; bash\"\ngnome-terminal -x sh -c \"hostapd conf/hostapd.conf; bash\"\n</code></pre>","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#references","title":"References","text":"<ul> <li>https://mirzafahad.github.io/2021-02-21-wifi-rouge-access-point-part1/</li> <li>https://mirzafahad.github.io/2021-03-07-wifi-rouge-access-point-part3/</li> </ul>","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#start-mqtt-mitm-proxy","title":"Start MQTT MitM Proxy","text":"<p>setup-ioxy.sh</p>","tags":["mitm","kali","iot"]},{"location":"guides/dotfiles/how-to-quickly-setup-a-wireless-mitm-proxy/index.html#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ol> <li>Why not VirtualBox?       I'm an open source guy, I like VirtualBox, but VMWare Player and VMWare Fusion just. work. </li> </ol> <code>#mitm</code> <code>#kali</code> <code>#iot</code>","tags":["mitm","kali","iot"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html","title":"Fancy Zones   Internals","text":"","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#basic-concepts","title":"Basic Concepts","text":"<p>At the most fundamental level, Fancy Zones works by: - Adding metadata to application windows indicating their size, origin, and \"zone\" - Listening for window events (drag, resize) and \"hooking\" them</p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#window-properties","title":"Window Properties","text":"<p>Metadata can be added to windows by leveraging Window Properties:</p> <p>A window property is any data assigned to a window. A window property is usually a handle of the window-specific data, but it may be any value. Each window property is identified by a string name.</p> <p>Window Detective can be used to view Window Properties.  In the example below, the picked window has the following Fancy Zones properties: - <code>FancyZones_RestoreSize</code> - <code>FancyZones_RestoreOrigin</code> - <code>FancyZones_TabSortKeyWithinZone</code> - <code>FancyZones_zones</code></p> <p></p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#fancyzoneswindowproperties","title":"FancyZonesWindowProperties","text":"<ul> <li><code>FancyZonesWindowProperties.h</code>  contains defines for all window properties used by Fancy Zones.</li> <li>FancyZonesWindowProperties.cpp contains the <code>StampZoneIndexProperty()</code> method, used to \"stamp\" window properties to window handles.</li> </ul>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#windows-events","title":"Windows Events","text":"<p>Windows is an event-based operating system, meaning, all windows generate and consume events.  Events can broadly be divided into two types: - WinEvents - Messages</p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#winevents","title":"WinEvents","text":"<p>Microsoft defines WinEvents thusly:</p> <p>Server applications and the operating system use WinEvents to notify clients when a change occurs in the system or in the user interface.</p> <p>WinEvent support is a feature of the Windows operating system that provides:</p> <ul> <li>A simple way for clients to register for event notifications.</li> <li>A mechanism for injecting client code into servers.</li> <li>Routing of events from servers to interested clients.</li> <li>Automatic event generation for most HWND-based controls.</li> </ul> <p>An application can \"listen\" for events by registering a hook.</p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#windows-hooks","title":"Windows Hooks","text":"<p>Microsoft defines hooks thusly: </p> <p>A hook is a mechanism by which an application can intercept events, such as messages, mouse actions, and keystrokes. A function that intercepts a particular type of event is known as a hook procedure. A hook procedure can act on each event it receives, and then modify or discard the event.</p> <p>Hooks can be one of the following: - In-Context - Out-of-Context</p> <p>There are two types of hooks <code>thread</code> and <code>global</code>.  Global hooks require DLL-injection.</p> <p>Hooks are set by registering a <code>WinEventProc</code> callback function using <code>SetWinEventHook</code>.</p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#fancyzonesappcpp","title":"FancyZonesApp.cpp","text":"<p>Fancy Zones calls SetWinEventHook  in <code>FancyZonesApp::InitHooks()</code> to subscribe to the following system-level and object-level events.  </p> <pre><code>    std::array&lt;DWORD, 7&gt; events_to_subscribe = {\nEVENT_SYSTEM_MOVESIZESTART,\nEVENT_SYSTEM_MOVESIZEEND,\nEVENT_OBJECT_NAMECHANGE,\nEVENT_OBJECT_UNCLOAKED,\nEVENT_OBJECT_SHOW,\nEVENT_OBJECT_CREATE,\nEVENT_OBJECT_LOCATIONCHANGE\n};\n</code></pre> <p>These event constants are detailed in the Windows documentation here, Event Constants.</p> <p>The hooked events are received in <code>FancyZonesApp</code>  and ultimately translated into Windows Messages which are consumed by the Fancy Zones <code>message loop</code> defined in^12f3b9|FancyZones.cpp.</p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#fancyzonescpp","title":"FancyZones.cpp","text":"<p>The <code>FancyZones</code> class is where most of the Fancy Zones business logic is defined.  </p> <p><code>FancyZones::HandleWinHookEvent()</code>  translates received events into internal Windows Messages which are consumed in <code>FancyZones::WndProc()</code>.</p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#windows-messages","title":"Windows Messages","text":"<p>Windows Messages are a type of event used by the operating system to provide external input to a window:</p> <p>Unlike MS-DOS-based applications, Windows-based applications are event-driven. They do not make explicit function calls (such as C run-time library calls) to obtain input. Instead, they wait for the system to pass input to them.</p> <p>The system passes all input for an application to the various windows in the application. Each window has a function, called a window procedure, that the system calls whenever it has input for the window. The window procedure processes the input and returns control to the system. For more information about window procedures, see Window Procedures.</p> <p>At the most basic level, all Windows GUI applications are simply a window and a message loop.</p> <p><code>Windows Detective</code> can be used to view Windows Events by right-clicking on a window handle and selecting \"Messages\".</p> <p></p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#clicking-maximize-button-on-notepad-toolbar","title":"Clicking Maximize button on Notepad Toolbar","text":"","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#clicking-full-screen-button-in-youtube-on-chrome","title":"Clicking \"Full Screen\" Button in Youtube on Chrome","text":"","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#maximize-in-zone-implementation","title":"\"Maximize in Zone\" Implementation","text":"","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#example-1-basic-implementation","title":"Example 1: Basic Implementation","text":"<p>Implementing a feature which resizes a \"maximized\" window so that it fits within the zone it is currently in.</p> <p>First, we need to determine what event is generated when the \"maximize\" button is pressed.  </p> <p>Using Microsoft Spy++, we see the following: </p> <p></p> <p>Ok, great!  It looks like the <code>WM_WINDOWPOSCHANGING</code> event gets fired, so we can hook that event.  Searching the Fancy Zones code base for <code>WM_WINDOWPOSCHANGING</code> yields... nothing.</p> <p>Hitting up Google, yields this interesting hit:</p> <ul> <li>https://stackoverflow.com/questions/17436795/setwineventhook-window-maximized-event <pre><code>void CALLBACK exampleHook(HWINEVENTHOOK hook, DWORD event, HWND hWnd,\nLONG idObject, LONG idChild, DWORD dwEventThread, DWORD dwmsEventTime)\n{\nif (EVENT_OBJECT_LOCATIONCHANGE == event) {\nWINDOWPLACEMENT wp;\nwp.length = sizeof(WINDOWPLACEMENT);\nGetWindowPlacement(hWnd, &amp;wp);\nif (SW_SHOWMAXIMIZED == wp.showCmd) {\n// Window is maximized.\n}\n}\n}\n</code></pre></li> </ul> <p>Ok, so this guy says to hook the <code>EVENT_OBJECT_LOCATIONCHANGE</code> event, let's search, which results in a few hits, all in <code>FancyZonesApp.cpp</code>: - One - Another</p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#step-1-update-fancyzonesappcpp","title":"Step 1: Update FancyZonesApp.cpp","text":"<p>First, update <code>FancyZonesApp.cpp</code> so that we're always listening to <code>EVENT_OBJECT_LOCATIONCHANGE</code> events.</p> <pre><code>    std::array&lt;DWORD, 7&gt; events_to_subscribe = {\nEVENT_SYSTEM_MOVESIZESTART,\nEVENT_SYSTEM_MOVESIZEEND,\nEVENT_OBJECT_NAMECHANGE,\nEVENT_OBJECT_UNCLOAKED,\nEVENT_OBJECT_SHOW,\nEVENT_OBJECT_CREATE,\nEVENT_OBJECT_LOCATIONCHANGE\n};\n</code></pre>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#step-2-update-fancyzonescpp","title":"Step 2: Update FancyZones.cpp","text":"<pre><code>else if (message == WM_PRIV_LOCATIONCHANGE)\n{\n// If the window is being resized via handle bars\nif (m_draggingState.IsDragging())\n{\nif (auto monitor = MonitorFromPoint(ptScreen, MONITOR_DEFAULTTONULL))\n{\nMoveSizeUpdate(monitor, ptScreen);\n}\n}\nelse\n{\nauto hwnd = reinterpret_cast&lt;HWND&gt;(wparam);\nif (FancyZonesWindowUtils::IsWindowMaximized(hwnd))\n{\nauto monitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONULL);\nMoveToAppLastZone(hwnd, monitor, NULL);\n}\n}\n}\n</code></pre>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#example-2-parent-windows","title":"Example 2: Parent Windows","text":"","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#example-3-dll-injection","title":"Example 3: DLL-Injection","text":"<p>There are two ways to inject DLLs: - SetWindowsHookEx() - CreateRemoteThread()</p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#setwindowshookex","title":"SetWindowsHookEx","text":"","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#considerations","title":"Considerations","text":"<ul> <li>Global vs per-Thread</li> <li>Hook type: WH_GETMESSAGE, WH_CALLWNDPROC, ...</li> <li>32-bit / 64-bit processes</li> <li>Windows Store Apps</li> </ul>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#debugging-tips","title":"Debugging Tips","text":"","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#createremotethread","title":"CreateRemoteThread","text":"","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#dll-injection-references","title":"DLL Injection References","text":"<ul> <li>https://www.apriorit.com/dev-blog/679-windows-dll-injection-for-api-hooks</li> <li>https://isaratech.com/cpp-dll-injection-using-createremotethread-on-windows/</li> <li>https://www.vicarius.io/blog/wtf-is-frida/</li> <li>https://github.com/rsmudge/vncdll/tree/master/rdll</li> </ul>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#references","title":"References","text":"<ul> <li>https://github.com/Taloth/PowerToys/commit/80ddcd08b9fa9537a4d5148735fe2fc9273aecb8</li> <li>https://github.com/microsoft/PowerToys/wiki/Fancy-Zones-deep-dive</li> <li>https://devblogs.microsoft.com/oldnewthing/20210104-00/?p=104656</li> <li> <p>http://www.winprog.org/tutorial/window_click.html</p> </li> <li> <p>https://stackoverflow.com/questions/1295999/event-when-a-window-gets-maximized-un-maximized <pre><code>protected override void WndProc(ref Message m)\n{\nbase.WndProc(ref m);\n// WM_SYSCOMMAND\nif (m.Msg == 0x0112)\n{\nif (m.WParam == new IntPtr(0xF030) // Maximize event - SC_MAXIMIZE from Winuser.h\n|| m.WParam == new IntPtr(0xF120)) // Restore event - SC_RESTORE from Winuser.h\n{\nUpdateYourUI();\n}\n}\n}\n</code></pre></p> </li> <li> <p>https://forums.codeguru.com/showthread.php?364445-How-to-detect-if-window-is-maximizing <pre><code>To detect if the window is maximizing, handle WM_SIZE and check wParam which will be SIZE_MAXIMIZED if maximized.\nYou can also use GetWindowPlacement to check whether a window is currently maximized or not.\n</code></pre></p> </li> </ul>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-internals/index.html#things-i-considered","title":"Things I Considered","text":"<ul> <li>Making application window a child of a parent window<ul> <li>https://windowtop.info/</li> <li>https://github.com/microsoft/PowerToys/issues/279#issuecomment-1145102438</li> </ul> </li> <li>DirectComposition<ul> <li>https://github.com/Microsoft/Windows.UI.Composition-Win32-Samples/tree/master/cpp/ScreenCaptureforHWND </li> <li>https://github.com/microsoft/PowerToys/issues/279#issuecomment-1144363857 </li> </ul> </li> </ul> <code>#powertoys</code> <code>#windows</code>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-overview/index.html","title":"Fancy Zones   Overview","text":"","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-overview/index.html#background","title":"Background","text":"<p>The impetus for this project is the desire to use my ultra-wide monitor in a more effective manner.  Specifically, I want to divide my monitor into \"zones\" which act emulate independent monitors.  </p> <p>Discussing this issue with the PowerToys team: - https://github.com/microsoft/PowerToys/issues/279 Taloth provided code for his implementation: - https://github.com/peddamat/PowerToys/discussions/5</p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-overview/index.html#overview","title":"Overview","text":"<p>The project is a Microsoft PowerToys fork. - Toolset: Microsoft Visual Studio 2022 - Repository: https://github.com/peddamat/PowerToys</p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-overview/index.html#how-to-see-what-i-changed","title":"How to see what I changed","text":"<p>https://github.com/microsoft/PowerToys/compare/main...peddamat:PowerToys:peddamat/maxInZoneDLL</p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-overview/index.html#references","title":"References","text":"<ul> <li>https://github.com/peddamat/visual-studio-projects (peddamat/final branch)</li> </ul>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-overview/index.html#setup","title":"Setup","text":"<ul> <li>Reference: https://github.com/microsoft/PowerToys/tree/main/doc/devdocs</li> </ul> <pre><code># Clone repository and submodules\ngit clone https://github.com/peddamat/PowerToys.git\ngit submodule update --init --recursive\n</code></pre>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-overview/index.html#open-solution","title":"Open Solution","text":"","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-overview/index.html#building-solution","title":"Building Solution","text":"<p>Before building the solution, it's best to <code>Clean Solution</code> to avoid random build failures.  Alternatively, you can go into <code>src\\modules\\previewpane</code> and type <code>git clean -xfd .</code>.</p> <p></p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-overview/index.html#running-solution","title":"Running Solution","text":"","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-overview/index.html#debugging-fancyzones","title":"Debugging FancyZones","text":"<p>The FancyZones module can be debugged by setting the Solution's \"Startup Project\" to FancyZones.  </p> <p></p>","tags":["powertoys","windows"]},{"location":"guides/fancy-zones/fancy-zones-overview/index.html#release-packaging","title":"Release Packaging","text":"<p>The installer is a separate solution found in the <code>\\installer</code> subfolder of the project.</p> <p></p> <p>A release can be built by typing the following commands in the root <code>PowerToys</code> folder:</p> <pre><code>git clean -xfd\n\nmsbuild -t:build -restore -p:RestorePackagesConfig=true /p:Configuration=Release /p:Platform=x64 PowerToys.sln\n\nmsbuild -t:build -restore -p:RestorePackagesConfig=true /p:Configuration=Release /p:Platform=x64 tools\\BugReportTool\\BugReportTool.sln\n\nmsbuild -t:build -restore -p:RestorePackagesConfig=true /p:Configuration=Release /p:Platform=x64 tools\\WebcamReportTool\\WebcamReportTool.sln\n\nmsbuild -t:build -restore -p:RestorePackagesConfig=true /p:Configuration=Release /p:Platform=x64 tools\\StylesReportTool\\StylesReportTool.sln\n\nmsbuild -t:build -restore -p:RestorePackagesConfig=true /p:Configuration=Release /p:Platform=x64 installer\\PowerToysSetup.sln\n</code></pre> <p></p> <code>#powertoys</code> <code>#windows</code>","tags":["powertoys","windows"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html","title":"Creating A DLL With Rust","text":"<p>In this four-part, project-based series I'll show you how to:</p> <ul> <li> Create a Windows dynamic-link library (DLL) using Rust</li> <li> Inject DLLs into processes using Process Hacker</li> <li> Inject DLLs into processes using Rust</li> <li> Create application windows using Rust</li> <li> Override a window's behavior using subclassing</li> </ul> <p>By the end of the series, you will build an injectable DLL that let's you \"full-screen\" a browser window without it taking up your entire screen:</p> <p></p> <p>Pretty cool, eh?</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#background","title":"Background","text":"<p>My interest in writing DLLs started, as with many things, as an attempt to scratch an itch.</p> <p>See, I have an ultrawide, and the problem with all ultrawides, is window management; more specifically, the lack of sane window management.</p> <p></p> <p>Instead of emulating a dual- or triple- monitor setup, operating systems treat your monitor as ONE BIGASS MONITOR, which I guess, well, yeah, who would have thought...</p> <p>Anyways, after evaluating many, many, many potential solutions, I landed on Microsoft's very own Fancy Zones, perfect in all ways, apart from one, when you \"Full Screen\" a YouTube video, the zone boundary is broken and the video consumes the entire screen.</p> <p>After a few weeks of hacking, I was able to cobble together a C++-based solution which utilized DLL-injection: peddamat/PowerToys</p> <p>This article series will walk through the development of an identical solution utilizing Rust.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#what-are-dlls","title":"What Are DLLs?","text":"<p>Microsoft describes them as:</p> <p>... a kind of executable file that acts as a shared library of functions and resources....</p> <p>More importantly:</p> <p>... (they) run in the context of the applications that call them. The operating system loads the DLL into an application's memory space. It's done either when the application is loaded (implicit linking), or on demand at runtime (explicit linking)...</p> <p>And an added bonus:</p> <p>Multiple applications can access the contents of a single copy of a DLL in memory at the same time.</p> <p>Key points being, DLLs are:</p> <ul> <li>similar to <code>.exe's</code></li> <li>loaded into an application's memory space</li> <li>shared between multiple applications</li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#compiling-your-first-dll","title":"Compiling Your First DLL","text":"","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#hellodll","title":"hello.dll","text":"<p>Let's begin by creating a new library crate called <code>hello</code>:</p> <pre><code>$ cargo new hello --lib\n</code></pre> <p>This should feel familiar, the <code>--lib</code> bit lets <code>cargo</code> know we want a library crate, which results in:</p> <pre><code>$ tree\n.\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 lib.rs\n</code></pre> <p><code>Cargo.toml</code> feels familiar\u2026</p> Cargo.toml<pre><code>[package]\nname = \"hello\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[dependencies]\n</code></pre> <p>\u2026 and <code>lib.rs</code> contains the library equivalent of a \"Hello World\":</p> lib.rs<pre><code>pub fn add(left: usize, right: usize) -&gt; usize {\nleft + right\n}\n#[cfg(test)]\nmod tests {\nuse super::*;\n#[test]\nfn it_works() {\nlet result = add(2, 2);\nassert_eq!(result, 4);\n}\n}\n</code></pre> <p>To build the crate, use:</p> <pre><code>$ cd hello\n$ cargo build\n</code></pre> <p>Which produces the following:</p> <pre><code>$ tree\n...\n\u2514\u2500\u2500 target\n    \u2514\u2500\u2500 debug\n        ...\n        \u2514\u2500\u2500 libhello.rlib\n</code></pre> <p>Unfortunately, <code>libhello.rlib</code> isn\u2019t a <code>.dll</code>.  It\u2019s actually something called a 'Rust library', intended for internal consumption within and between Rust programs.</p> <p>To produce a <code>.dll</code>, we must add a <code>crate-type</code> specifier to <code>Cargo.toml</code>:</p> Cargo.toml<pre><code>[package]\nname = \"hello\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[lib]\ncrate-type = [\"cdylib\"]\n[dependencies]\n</code></pre> <p>Building the project now results in:</p> <pre><code>$ cargo build\n   Compiling hello v0.1.0 (C:\\Users\\me\\source\\blog_qa\\hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.66s\n\n$ tree\n.\n\u2514\u2500\u2500 target\n    \u2514\u2500\u2500 debug\n        ...\n        \u2514\u2500\u2500 hello.dll\n</code></pre> <p>Hooray!</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#wait-what","title":"Wait, what?","text":"<p>The <code>crate-type</code> attribute allows us to specify what sort of artifacts we want <code>cargo</code> to generate for us.</p> <p>The full list can be found here, but a good summary is:</p> <ul> <li><code>bin</code>: ordinary executable.</li> <li><code>lib</code>: a library to be linked statically into Rust programs.</li> <li><code>dylib</code>: a library to be linked dynamically into Rust programs.</li> <li><code>staticlib</code>: a library to be linked statically into non-Rust programs.</li> <li><code>cdylib</code>: a library to be linked dynamically into non-Rust programs.</li> <li>source</li> </ul> <p>We use the <code>cdylib</code> crate type because our ultimate goal is to inject <code>hello.dll</code> into an existing Windows process, which, let's be honest, is likely non-Rust.   However, feel free to try this project with using the <code>dylib</code>.</p> <p>In addition to <code>hello.dll</code>, Rust produces a number of other artifacts:</p> <ul> <li><code>*.d</code> \u2014 Makefile-compatible dependency lists</li> <li><code>*.rlib</code> \u2014 Rust library files. Contain the compiled code of a dependency</li> <li><code>build</code> \u2014 Directories for build scripts to use as scratch space</li> <li><code>deps</code> \u2014 Your compiled dependencies</li> <li><code>examples</code> \u2014 Binaries from the <code>examples</code> directory</li> <li><code>incremental</code> \u2014 A directory for the incremental compilation cache</li> <li><code>*-{hash}</code> \u2014 Binaries from <code>cargo test</code></li> <li>executables \u2014 Your target binaries</li> </ul> <p>You can read more about them: here</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#further-reading","title":"Further Reading","text":"<ul> <li>What is the Difference Between <code>dylib</code> and <code>cdylib</code></li> <li>The Rust Reference: Linkage</li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#using-your-first-dll","title":"Using Your First DLL","text":"","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#hello_runnerexe","title":"hello_runner.exe","text":"<p>Let's put our fresh <code>hello.dll</code> to use by creating a new binary crate called <code>hello_runner</code>:</p> <pre><code>$ cd ..\n$ cargo new hello_runner\n</code></pre> <p>Next, let's indicate a dependency on the <code>hello</code> crate by adding a line to the <code>[dependencies]</code> block in <code>Cargo.toml</code>:</p> Cargo.toml<pre><code>[package]\nname = \"hello_runner\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[dependencies]\nhello = { path = \"../hello\" }\n</code></pre> <p>Let's replace <code>hello_runner's</code> <code>main.rs</code> with something simple, just to make sure <code>hello.dll</code> is linked:</p> main.rs<pre><code>fn main() {\nprintln!(\"2+2={}\", add(2,2));\n}\n</code></pre> <p>Oh look, rust-analyzer is already screaming at us:</p> <p></p> <p>It seems merely specifying the dependency on <code>hello</code> in <code>Cargo.toml</code> isn't enough for Rust to find <code>add()</code> in <code>hello.dll</code>.</p> <p>So to tell Rust that there indeed exists an <code>add()</code> out there, somewhere, we can add an extern block to the top of <code>main.rs</code>:</p> main.rs<pre><code>extern {\nfn add(left: usize, right: usize) -&gt; usize;\n}\n</code></pre> <p>rust-analyzer is still dissatisfied:</p> <p></p> <p>Following along carefully, we add an <code>unsafe</code> block, and...</p> <pre><code>extern {\nfn add(left: usize, right: usize) -&gt; usize;\n}\nfn main() {\nunsafe {\nprintln!(\"2+2={}\", add(2,2));\n}\n}\n</code></pre> <p>... silence, perfect!</p> <p>Doing a quick <code>cargo build</code>:</p> <pre><code>$ cargo build\n\nwarning: The package `hello` provides no linkable target. The compiler might raise an error while compiling `hello_runner`. Consider adding 'dylib' or 'rlib' to key `crate-type` in `hello`'s Cargo.toml. This warning might turn into a hard error in the future.\n   Compiling hello v0.1.0 (C:\\Users\\me\\source\\blog_qa\\hello)\nCompiling hello_runner v0.1.0 (C:\\Users\\me\\source\\blog_qa\\hello_runner)\nerror: linking with `link.exe` failed: exit code: 1120\n|\n...\n  = note: hello_runner.3x2hoz24wh045sx8.rcgu.o : error LNK2019: unresolved external symbol add referenced in function _ZN12hello_runner4main17h5d530bb84e958f44E\n          C:\\Users\\me\\source\\blog_qa\\hello_runner\\target\\debug\\deps\\hello_runner.exe : fatal error LNK1120: 1 unresolved externals\nerror: could not compile `hello_runner` due to previous error\n</code></pre> <p>What fresh hell...</p> <p>Ok, re-reading The Book's External Block section a bit more thoroughly, we see that we can specify a <code>link</code> attribute:</p> main.rs<pre><code>#[link(name = \"hello.dll\", kind=\"dylib\")]\nextern {\nfn add(left: usize, right: usize) -&gt; usize;\n}\nfn main() {\nunsafe {\nprintln!(\"2+2={}\", add(2,2));\n}\n}\n</code></pre> <p><code>cargo build</code>:</p> <pre><code>$ cargo build\nwarning: The package `hello` provides no linkable target. The compiler might raise an error while compiling `hello_runner`. Consider adding 'dylib' or 'rlib' to key `crate-type` in `hello`'s Cargo.toml. This warning might turn into a hard error in the future.\nCompiling hello_runner v0.1.0 (C:\\Users\\me\\source\\blog_qa\\hello_runner)\nerror: linking with `link.exe` failed: exit code: 1120\n|\n...\n= note: hello_runner.3x2hoz24wh045sx8.rcgu.o : error LNK2019: unresolved external symbol __imp_add referenced in function _ZN12hello_runner4main17h5d530bb84e958f44E\nC:\\Users\\me\\source\\blog_qa\\hello_runner\\target\\debug\\deps\\hello_runner.exe : fatal error LNK1120: 1 unresolved externals\nerror: could not compile `hello_runner` due to previous error\n</code></pre> <p>Weeps.</p> <p>Ok, pulling out the goddamn cdylib RFC, which helpfully explains:</p> <p>Symbol visibility - rdylibs will expose all symbols as rlibs do, cdylibs will expose symbols as executables do. This means that <code>pub fn foo() {}</code> will not be an exported symbol, but <code>#[no_mangle] pub extern fn foo() {}</code> will be an exported symbol.</p> <p>Adding the <code>#[no_mangle] pub extern</code> to <code>add()</code>:</p> main.rs<pre><code>#[no_mangle]\npub extern fn add(left: usize, right: usize) -&gt; usize {\nleft + right\n}\n</code></pre> <p><code>cargo build</code>:</p> <pre><code>$ cargo build\nwarning: The package `hello` provides no linkable target. The compiler might raise an error while compiling `hello_runner`. Consider adding 'dylib' or 'rlib' to key `crate-type` in `hello`'s Cargo.toml. This warning might turn into a hard error in the future.\n   Compiling hello v0.1.0 (C:\\Users\\me\\source\\blog_qa\\hello)\nCompiling hello_runner v0.1.0 (C:\\Users\\me\\source\\blog_qa\\hello_runner)\nFinished dev [unoptimized + debuginfo] target(s) in 0.80s\n</code></pre> <p>Thank you god.   That warning is odd, though...</p> <pre><code>$ tree\n.\n\u2514\u2500\u2500 target\n    \u2514\u2500\u2500 debug\n        ...\n        \u251c\u2500\u2500 hello_runner.exe\n        ...\n</code></pre> <p>Let's see if <code>hello_runner.exe</code> runs using <code>cargo run</code>:</p> <pre><code>$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.01s\n     Running `target\\debug\\hello_runner.exe`\n2+2=4\n</code></pre> <p>Da dum!</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#upon-further-examination","title":"Upon Further Examination...","text":"<p>Ok, thus far we've been using <code>cargo run</code> to execute <code>hello_runner</code>, but for shits and giggles, let's try running <code>hello_runner.exe</code> directly:</p> <pre><code>$ target\\debug\\hello_runner.exe\n\n$\n</code></pre> <p>wat.</p> <pre><code>$ ls -l\nbuild\ndeps\nexamples\nhello_runner.d\nhello_runner.exe\nhello_runner.pdb\nincremental\n</code></pre> <p>Ah... <code>hello.dll</code> isn't in the same directory as <code>hello_runner.exe</code>...</p> <pre><code>$ cp deps\\hello.dll .\n$ hello_runner.exe\n2+2=4\n</code></pre> <p>Bingo.  Ok, so that little exercise gives us a fairly good idea that <code>hello_runner.exe</code> has indeed \u201cdynamically\u201d-linked <code>hello.dll</code>, but how do we know for sure?</p> <p>If you have Visual Studio installed, chances are you have a handy tool called <code>dumpbin.exe</code>, which is available using a \"Developer Command Prompt for VS 2022\".</p> <p>View <code>hello.dll</code>'s exported functions using <code>dumpbin /exports</code>:</p> <pre><code>$ dumpbin /exports hello.dll\nMicrosoft (R) COFF/PE Dumper Version 14.34.31942.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nDump of file hello.dll\n\nFile Type: DLL\n\nSection contains the following exports for hello.dll\n\n00000000 characteristics\n    FFFFFFFF time date stamp\n        0.00 version\n           1 ordinal base\n           1 number of functions\n           1 number of names\n\nordinal hint RVA      name\n\n1    0 00001000 add = add\n\nSummary\n\n1000 .data\n        1000 .pdata\n        7000 .rdata\n        1000 .reloc\n       18000 .text\n</code></pre> <p>View <code>hello_runner.exe</code>'s imported functions using <code>dumpbin /imports</code>:</p> <pre><code>$ dumpbin /imports hello_runner.exe |more\nMicrosoft (R) COFF/PE Dumper Version 14.34.31942.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nDump of file hello_runner.exe\n\nFile Type: EXECUTABLE IMAGE\n\nSection contains the following imports:\n\nhello.dll\n             14001E2A0 Import Address Table\n             140026CC8 Import Name Table\n                     0 time date stamp\n                     0 Index of first forwarder reference\n\n0 add\n\nKERNEL32.dll\n  ...\n</code></pre> <p>For the more visually included, the venerable x64dbg or Dependencies can also be used to inspect <code>hello_runner.exe</code>:</p> <p></p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#wait-what_1","title":"Wait, what?","text":"<p>Eagle-eyed readers may have noticed the the <code>kind=\"dylib\"</code> in the <code>main.rs</code> <code>#[link...</code> block:</p> main.rs<pre><code>#[link(name = \"hello.dll\", kind=\"dylib\")]\nextern {\nfn add(left: usize, right: usize) -&gt; usize;\n}\n</code></pre> <p>The external blocks#link-attribute section explains :</p> <ul> <li><code>dylib</code> \u2014 Indicates a dynamic library. This is the default if <code>kind</code> is not specified.</li> <li><code>static</code> \u2014 Indicates a static library.</li> <li><code>framework</code> \u2014 Indicates a macOS framework. This is only valid for macOS targets.</li> <li><code>raw-dylib</code> \u2014 Indicates a dynamic library where the compiler will generate an import library to link against (see <code>dylib</code> versus <code>raw-dylib</code> below for details). This is only valid for Windows targets.</li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#further-reading_1","title":"Further Reading","text":"<ul> <li>Linking Rust Crates, Part 1</li> <li>How to dynamically link to a dynamic library? -C prefer-dynamic doesn't seems to work</li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#pulling-bootstraps","title":"Pulling Bootstraps","text":"<p>As it currently stands, our humble <code>hello.dll</code> doesn't do much;  essentially a glorified wastebasket at the beck and call of any old binary that links up with it.</p> <p>Let's give our <code>hello.dll</code> a bit of agency by defining an entry-point.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#dllmain","title":"DllMain","text":"<p>What is an entry-point?  In short, whenever Windows loads a DLL, it checks to see if it exports a function named <code>DllMain</code>.  If so, the operating system calls the function with a <code>DLL_PROCESS_ATTACH</code> or <code>DLL_PROCESS_DETACH</code> when attaching or detaching the DLL to processes.</p> <p>Let's see how this works be adding a <code>DllMain</code> to <code>hello.dll</code>.</p> <p>First, we'll need to add a few <code>windows-rs</code> crates to the <code>hello</code> crate's <code>cargo.toml</code>:</p> Cargo.toml<pre><code>[dependencies.windows]\nversion = \"0.*\"\nfeatures = [\n\"Win32_Foundation\",\n\"Win32_System_SystemServices\",\n\"Win32_UI_WindowsAndMessaging\",\n]\n</code></pre> <p>Next, we can add a barebones implementation of <code>DllMain</code> to the top of <code>lib.rs</code>:</p> lib.rs<pre><code>use windows::{ Win32::Foundation::*, Win32::System::SystemServices::*, };\n#[no_mangle]\n#[allow(non_snake_case, unused_variables)]\nextern \"system\" fn DllMain(\ndll_module: HINSTANCE,\ncall_reason: u32,\n_: *mut ())\n-&gt; bool\n{\nmatch call_reason {\nDLL_PROCESS_ATTACH =&gt; (),\nDLL_PROCESS_DETACH =&gt; (),\n_ =&gt; ()\n}\ntrue\n}\n</code></pre> <p>A quick <code>cargo check</code> in either <code>/hello</code>  or <code>/hello_runner</code> shows that we're on the right path:</p> <pre><code>$ cargo\n    Finished dev [unoptimized + debuginfo] target(s) in 0.04s\n</code></pre> <p>Let's have our DLL do something when it receives a <code>DLL_PROCESS_ATTACH</code> and <code>DLL_PROCESS_DETACH</code>:</p> lib.rs<pre><code>use windows::{ Win32::Foundation::*, Win32::System::SystemServices::*, };\nuse windows::{ core::*, Win32::UI::WindowsAndMessaging::MessageBoxA, };\n#[no_mangle]\n#[allow(non_snake_case, unused_variables)]\nextern \"system\" fn DllMain(\ndll_module: HINSTANCE,\ncall_reason: u32,\n_: *mut ())\n-&gt; bool\n{\nmatch call_reason {\nDLL_PROCESS_ATTACH =&gt; attach(),\nDLL_PROCESS_DETACH =&gt; detach(),\n_ =&gt; ()\n}\ntrue\n}\nfn attach() {\nunsafe {\n// Create a message box\nMessageBoxA(HWND(0),\ns!(\"ZOMG!\"),\ns!(\"hello.dll\"),\nDefault::default()\n);\n};\n}\nfn detach() {\nunsafe {\n// Create a message box\nMessageBoxA(HWND(0),\ns!(\"GOODBYE!\"),\ns!(\"hello.dll\"),\nDefault::default()\n);\n};\n}\n</code></pre> <p>Run the <code>hello_runner</code> crate using <code>cargo run</code>:</p> <pre><code>$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.06s\n     Running `target\\debug\\hello_runner.exe`\n2+2=4\n</code></pre> <p>and...</p> <p></p> <p>and then...</p> <p></p> <p>Boom!</p> <p>Well... I'll admit that I may have been talking things a bit up.</p> <p>That did  feel a bit anti-climatic; theoretical, even;  far too ivory tower to be satisfying.</p> <p>Let's remedy this by slamming <code>hello.dll</code> into a random process using DLL injection.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#further-reading_2","title":"Further Reading","text":"<ul> <li>About Dynamic-Link Libraries</li> <li>Exporting from a DLL</li> <li>DllMain entry point</li> <li>Implementing DllMain</li> <li>Dynamic-Link Library Entry-Point Function</li> <li>X-rays5/rust_win32_dllmain</li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#injecting-the-gd-thing-into-notepadexe","title":"Injecting The GD Thing Into Notepad.exe","text":"<p>So what is \"DLL Injection\"?  Basically, it's leetspeek for using publically available Windows API calls to load a DLL into an unsuspecting application's memory space,  with bonus points if you can actually execute code from the DLL in the application's memory space.</p> <p>We will do both, but since the day grows old, we'll take the script kiddie route and use the handy \"Process Hacker\" tool.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#but-first","title":"But First...","text":"<p>Let's make a small tweak to the <code>attach()</code> function in <code>lib.rs</code>, because we really want to feel the next part in our veins.</p> <p>Add this to the top of <code>lib.rs</code>: lib.rs<pre><code>use windows::Win32::System::Threading::GetCurrentProcessId;\n</code></pre></p> <p>Since we added that, we need to also update our <code>[dependencies.windows]</code> in Cargo.toml`: Cargo.toml<pre><code>[dependencies.windows]\nversion = \"0.*\"\nfeatures = [\n\"Win32_Foundation\",\n\"Win32_System_SystemServices\",\n\"Win32_UI_WindowsAndMessaging\",\n\"Win32_System_Threading\"\n]\n</code></pre></p> <p>And make <code>attach()</code> look like this lib.rs<pre><code>fn attach() {\nunsafe {\nlet pid = GetCurrentProcessId();\nMessageBoxA(HWND(0),\nPCSTR(std::format!(\"Hello from process: {}!\\0\", pid).as_ptr()),\ns!(\"hello.dll\"),\nDefault::default()\n);\n};\n}\n</code></pre></p> <p>And finally:</p> <pre><code>$ cargo run\nwarning: The package `hello` provides no linkable target. The compiler might raise an error while compiling `hello_runner`. Consider adding 'dylib' or 'rlib' to key `crate-type` in `hello`'s Cargo.toml. This warning might turn into a hard error in the future.\n   Compiling windows v0.44.0\n   Compiling hello v0.1.0 (C:\\Users\\me\\source\\blog_qa\\hello)\nCompiling hello_runner v0.1.0 (C:\\Users\\me\\source\\blog_qa\\hello_runner)\nFinished dev [unoptimized + debuginfo] target(s) in 6.74s\n     Running `target\\debug\\hello_runner.exe`\n</code></pre> <p></p> <p>And we get our updated pop-up, good.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#process-hacker","title":"Process Hacker","text":"<p>Now, grab Process Hacker: here and launch the <code>x64</code> version.</p> <p>If you closed the previous pop-up, do another <code>cargo run</code> and search for \"hello_runner.exe\" in the little search bar near the top right of the window.</p> <p></p> <p>Compare the contents of the PID column with the number in the pop-up.  For me, I get the same number, 33640.</p> <p>Now hit <code>Enter</code> (or right-click -&gt; Properties) to open the \"Properties\" panel:</p> <p></p> <p>The 'Threads' tab shows us that <code>hello_runner.exe</code> is using a single thread with a \"Thread ID\" (TID) of 18676.</p> <p>Clicking on the 'Modules' tab shows us that <code>hello.dll</code> is indeed loaded into <code>hello_runner.exe's</code> address space, in fact, it's at <code>0x7ffb5e7d0000</code> for me:</p> <p></p> <p>All of this makes sense, since <code>hello_runner.exe</code> is literally loading <code>hello.dll</code>, right?</p> <p>Well, I don't remember using <code>LoadLibraryW</code> anywhere...  but we did slap <code>#[link(name = \"hello.dll\", kind=\"dylib\")]</code> on that <code>extern</code> in hello_runner's <code>main.rs</code>.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#implicit-vs-explicit-linking","title":"Implicit vs Explicit linking","text":"<p>If we stroll down Memory Lane, recall:</p> <p>... (they) run in the context of the applications that call them. The operating system loads the DLL into an application's memory space. It's done either when the application is loaded (implicit linking), or on demand at runtime (explicit linking)...</p> <p>Specifically,</p> <p>It's done either when the application is loaded (implicit linking), or on demand at runtime (explicit linking)...</p> <p>So, though we didn't directly call <code>LoadLibraryW</code> to load <code>hello.dll</code> we did define a runtime dependency on it; we explicitly linked it.</p> <p>Later on, when we actually do use <code>LoadLibraryW</code>, we'll be implicitly linking it.  Something to keep in mind in case you never need that information.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#actually-injecting-teh-dll","title":"Actually Injecting teh DLL","text":"<p>Ok, finally , open up a Notepad instance, and find it in Process Hacker:</p> <p></p> <p>Next, right click on the <code>notepad.exe</code> process and find <code>Inject DLL</code> under the <code>Miscellaneous</code> context menu.</p> <p></p> <p>Find <code>hello.dll</code> in the hello_runner\\target\\debug\\deps folder and click \"Open\":</p> <p></p> <p>If you didn't have Notepad in the foreground, you may have to hunt for it...</p> <p></p> <p>But you will be rewarded with a...</p> <p></p> <p></p> <p>You can confirm that <code>hello.dll</code> has indeed been loaded into <code>notepad.exe</code>'s address space by opening up the <code>Modules</code> tab in Process Hacker's <code>Properties</code> panel.</p> <p></p> <p>Be sure to Unload <code>hello.dll</code> before you go:</p> <p></p> <p>Giving you a:</p> <p></p> <p>In general, it is always good practice to make sure your DLL is well behaved both loading and unloading.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#just-a-little-further","title":"Just A Little Further","text":"","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-dll-with-rust/index.html#rust-workspaces","title":"Rust Workspaces","text":"<p>When injecting <code>hello.dll</code> above, you may noticed that there are actually two <code>hello.dll</code> binaries on our filesystem: one in <code>\\hello_runner\\target\\debug\\deps</code> and one in <code>\\hello\\target\\debug</code>.</p> <p>If you had the misfortune of trying to inject <code>hello.dll</code> from the latter, you'd have noticed that nothing happened.  Why?  Because it was a stale binary, left over from an earlier part of the tutorial when we were working in the <code>hello</code> crate context.</p> <p>To reduce this confusion, Rust provides us with the workspace concept, which allows us to group dependent crates into a single... workspace.</p> <p>First, let's do a bit of tidying, do a <code>cargo clean</code> from both the <code>hello</code> and <code>hello_runner</code> directories.</p> <p>Now, in the parent folder, create a <code>Cargo.toml</code> containing:</p> Cargo.toml<pre><code>[workspace]\nmembers = [\n\"hello\",\n\"hello_runner\",\n]\n</code></pre> <p>The directory should look like this:</p> <pre><code>$ tree -L 1 -a\n.\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 hello\n\u2514\u2500\u2500 hello_runner\n</code></pre> <p>Do a <code>cargo build</code>:</p> <pre><code>$ cargo build\nwarning: The package `hello` provides no linkable target. The compiler might raise an error while compiling `hello_runner`. Consider adding 'dylib' or 'rlib' to key `crate-type` in `hello`'s Cargo.toml. This warning might turn into a hard error in the future.\n   Compiling windows_x86_64_msvc v0.42.1\n   Compiling windows-targets v0.42.1\n   Compiling windows v0.44.0\n   Compiling hello v0.1.0 (C:\\Users\\me\\source\\blog_qa\\hello)\nCompiling hello_runner v0.1.0 (C:\\Users\\me\\source\\blog_qa\\hello_runner)\nFinished dev [unoptimized + debuginfo] target(s) in 6.92s\n</code></pre> <p>Which results in:</p> <pre><code>$ tree -L 3 -a\n.\n\u251c\u2500\u2500 Cargo.lock\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 hello\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 .gitignore\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.lock\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.toml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 lib.rs\n\u251c\u2500\u2500 hello_runner\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 .gitignore\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.lock\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.toml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 main.rs\n\u2514\u2500\u2500 target\n    ...\n    \u2514\u2500\u2500 debug\n        ...\n        \u251c\u2500\u2500 hello.dll\n        \u251c\u2500\u2500 hello_runner.exe\n        ...\n</code></pre> <p>Notice that we now only have one <code>target</code> directory.</p> <p>If you do a <code>cargo run</code>, you'll notice cargo is smart enough to execute <code>hello_runner.exe</code>:</p> <pre><code>$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.05s\n     Running `target\\debug\\hello_runner.exe`\n2+2=4\n</code></pre> <p>Lastly, if you're so inclined, do a <code>git init</code> and call it a night!</p> <p>Part 2 is here: Creating A Window With Rust</p> <p>Having trouble? The code this series can be found here: peddamat/how-to-create-a-dll-using-rust</p> <p></p> <code>#rust</code> <code>#dll</code> <code>#howto</code> <code>#windows</code> <code>#programming</code>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html","title":"Creating A Window With Rust","text":"<p>If you've been following along from Creating A DLL With Rust, you should know how to do the following:</p> <ul> <li> Create a Windows dynamic-link library (DLL) using Rust</li> <li> Inject DLLs into processes using Process Hacker</li> <li> Inject DLLs into processes using Rust</li> <li> Create application windows using Rust</li> <li> Override a window's behavior using subclassing</li> </ul> <p>In today's exercise, we are going to skip a step and learn about windows: how they work, how to create them, and how to customize them using something called subclassing.</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#what-are-windows","title":"What Are Windows?","text":"<p>We spend all day interacting with windows,  but how much do we really know about them?</p> <p>By the end of this series we'll be elbow deep in them, so it's worth spending a moment to understand them more intimately.</p> <p>Fortunately, Microsoft\u2019s documentation on this topic is fantastic: About Windows.</p> <p>Take a few moments to peruse and come back here.  I'll wait.</p> <p>Ok, sketching out what we just read, GUI applications look something like this: </p> <p></p> <ul> <li>Every application has a WinMain entry-point function</li> <li>Every application must create at least one window</li> <li>Every window belongs to one window class</li> <li>Every window has one unique window handle</li> <li>Every window has one GUI thread</li> <li>Every GUI thread has one message queue</li> <li>Every window class contains one window procedure</li> </ul> <p>And, Windows is a message-based system, where:</p> <ul> <li>Every message sent or posted to a window is processed by its window procedure</li> <li>Every message posted to a window is placed in its message queue</li> <li>Every window must remove and process messages posted to its message queue</li> </ul>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#further-reading","title":"Further Reading","text":"<ul> <li>GetMessage#Remarks</li> <li>When can a thread receive window messages?</li> <li>Windows and Messages</li> <li>Windows Programming/Message Loop Architecture</li> </ul>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#overall-structure","title":"Overall Structure","text":"<p>Your First Windows Program presents a prototypical GUI application:  </p> <pre><code>#include &lt;windows.h&gt;\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\nint WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)\n{\n// Register the window class.\nconst wchar_t CLASS_NAME[]  = L\"Sample Window Class\";\nWNDCLASS wc = { };\nwc.lpfnWndProc   = WindowProc;\nwc.hInstance     = hInstance;\nwc.lpszClassName = CLASS_NAME;\nRegisterClass(&amp;wc);\n// Create the window.\nHWND hwnd = CreateWindowEx(\n...\nCLASS_NAME, // Window class\n...\n);\nif (hwnd == NULL)\n{\nreturn 0;\n}\nShowWindow(hwnd, nCmdShow);\n// Run the message loop.\nMSG msg = { };\nwhile (GetMessage(&amp;msg, NULL, 0, 0) &gt; 0)\n{\nTranslateMessage(&amp;msg);\nDispatchMessage(&amp;msg);\n}\nreturn 0;\n}\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\nswitch (uMsg)\n{\ncase WM_DESTROY:\nPostQuitMessage(0);\nreturn 0;\n...\n}\nreturn DefWindowProc(hwnd, uMsg, wParam, lParam);\n}\n</code></pre> <p>With the code's comments delineating three functional areas:</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#1-the-window-class","title":"1. The Window Class","text":"<p>Creates and registers a \"window class\", which is simply a  <code>WNDCLASS</code> struct.  </p> <p>At minimum we have to provide:</p> <ul> <li>a pointer to a WNDPROC callback function</li> <li>a handle to the .exe/.dll containing the WNDPROC</li> <li>a unique class name</li> </ul> <pre><code>// Register the window class.\nconst wchar_t CLASS_NAME[]  = L\"Sample Window Class\";\nWNDCLASS wc = { };\nwc.lpfnWndProc   = WindowProc;  // Pointer to \"window procedure\"\nwc.hInstance     = hInstance;\nwc.lpszClassName = CLASS_NAME;  // Unique class name\nRegisterClass(&amp;wc);             // Tell Windows about the new window class \n</code></pre>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#2-window-instantiation","title":"2. Window Instantiation","text":"<p>Creates a new window, using the specs we defined in <code>WNDCLASS</code>, and displays the window to the screen:</p> <p><pre><code>// Create the window.\nHWND hwnd = CreateWindowEx(\n...\nCLASS_NAME, // Window class\n...\n);\nif (hwnd == NULL)\n{\nreturn 0;\n}\n// Display window to screen\nShowWindow(hwnd, nCmdShow);\n</code></pre> <code>CreateWindowEx</code> returns a \"handle\" aka \u201cwindow handle\", to the created window.</p> <p>Window handles are unique to each created window, allowing us to reference them in our code.</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#3-the-message-loop","title":"3. The Message Loop","text":"<p>Continuously calls <code>GetMessage</code> to grab messages sent to the window and dispatch them to the window's Window Procedure using <code>DispatchMessage</code>:</p> <pre><code>// Run the message loop.\nMSG msg = { };\nwhile (GetMessage(&amp;msg, NULL, 0, 0) &gt; 0)\n{\nTranslateMessage(&amp;msg);\nDispatchMessage(&amp;msg);\n}\n</code></pre>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#the-window-procedure","title":"The Window Procedure","text":"<p>Receives and processes the window's messages, handing-off unprocessed messages to the operating system by calling <code>DefWindowProc</code>:</p> <pre><code>LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\nswitch (uMsg)\n{\ncase WM_DESTROY:\nPostQuitMessage(0);\nreturn 0;\n...\n}\nreturn DefWindowProc(hwnd, uMsg, wParam, lParam);\n}\n</code></pre>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#further-reading_1","title":"Further Reading","text":"<ul> <li>Using Messages and Message Queues</li> </ul>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#actually-creating-the-window","title":"Actually Creating The Window","text":"<p>The <code>windows-rs</code> crate provides a <code>create_window</code>  sample, a Rust version of what we examined above:</p> main.rs<pre><code>use windows::{\ncore::*, Win32::Foundation::*, Win32::Graphics::Gdi::*,\nWin32::System::LibraryLoader::GetModuleHandleA,\nWin32::UI::WindowsAndMessaging::*,\n};\nfn main() -&gt; Result&lt;()&gt; {\nunsafe {\nlet instance = GetModuleHandleA(None)?;\ndebug_assert!(instance.0 != 0);\nlet window_class = s!(\"window\");\nlet wc = WNDCLASSA {\nhCursor: LoadCursorW(None, IDC_ARROW)?,\nhInstance: instance,\nlpszClassName: window_class,\nstyle: CS_HREDRAW | CS_VREDRAW,\nlpfnWndProc: Some(wndproc),\n..Default::default()\n};\nlet atom = RegisterClassA(&amp;wc);\ndebug_assert!(atom != 0);\nCreateWindowExA(\nWINDOW_EX_STYLE::default(),\nwindow_class,\ns!(\"This is a sample window\"),\nWS_OVERLAPPEDWINDOW | WS_VISIBLE,\nCW_USEDEFAULT,\nCW_USEDEFAULT,\n800,\n600,\nNone,\nNone,\ninstance,\nNone,\n);\nlet mut message = MSG::default();\nwhile GetMessageA(&amp;mut message, HWND(0), 0, 0).into() {\nDispatchMessageA(&amp;message);\n}\nOk(())\n}\n}\nextern \"system\" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -&gt; LRESULT {\nunsafe {\nmatch message {\nWM_PAINT =&gt; {\nprintln!(\"WM_PAINT\");\nValidateRect(window, None);\nLRESULT(0)\n}\nWM_DESTROY =&gt; {\nprintln!(\"WM_DESTROY\");\nPostQuitMessage(0);\nLRESULT(0)\n}\n_ =&gt; DefWindowProcA(window, message, wparam, lparam),\n}\n}\n}\n</code></pre>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#getting-the-code","title":"Getting the Code","text":"<p>The <code>windows-rs</code> repo is pretty large, so if you want to save time, you can <code>git clone</code> just the <code>create_window</code> folder from my repo here: peddamat/create_window</p> <p>Cloning it into our workspace folder:</p> <p><pre><code>$ git clone https://github.com/peddamat/create_window.git\n\n$ tree\n.\n\u251c\u2500\u2500 Cargo.lock\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 create_window\n\u251c\u2500\u2500 hello\n\u251c\u2500\u2500 hello_runner\n\u2514\u2500\u2500 target\n</code></pre> fyi, you can grab all the windows-rs samples: here</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#updating-your-workspace","title":"Updating Your Workspace","text":"<p>Add the crate to your workspace's <code>Cargo.toml</code>:</p> Cargo.toml<pre><code>[workspace]\nmembers = [\n\"hello\",\n\"hello_runner\",\n\"create_window\",\n]\n</code></pre>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#running-the-code","title":"Running the Code","text":"<p>Now, do a <code>cargo run</code>:</p> <pre><code>$ cargo run\nerror: `cargo run` could not determine which binary to run. Use the `--bin` option to specify a binary, or the `default-run` manifest key.\navailable binaries: create_window, hello_runner\n</code></pre> <p>Ah, so <code>cargo run --bin create_window</code> it is!</p> <pre><code>$ cargo run --bin create_window\nwarning: C:\\Users\\me\\source\\blog_qa\\create_window\\Cargo.toml: dependency (windows-sys) specified without providing a local path, Git repository, or version to use. This will be considered an error in future versions\n    Updating crates.io index\n   Compiling windows-sys v0.45.0\n   Compiling create_window v0.0.0 (C:\\Users\\me\\source\\blog_qa\\create_window)\nFinished dev [unoptimized + debuginfo] target(s) in 4.91s\n     Running `target\\debug\\create_window.exe`\nWM_PAINT\n</code></pre> <p>And now we're cooking with windows!</p> <p></p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#further-reading_2","title":"Further Reading","text":"<ul> <li>Module 1. Your First Windows Program</li> <li>Raymond Chen: The scratch program</li> <li>winit - Cross-platform window creation and management in Rust</li> </ul>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#window-messages","title":"Window Messages","text":"<p>As we learned earlier, Windows is message-based, meaning, all user input and requests are sent to the window using messages.</p> <p>\u201dThe system\u201d (Windows) internally defines 100\u2019s of messages, but we\u2019re usually only interested in a handful of them.   </p> <p>To get a better handle on which messages matter, let's see them with our own eyes using Window Detective.</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#window-detective","title":"Window Detective","text":"<p>It looks like this:</p> <p></p> <p>Use the 'Pick window' tool to \"pick\" the <code>create_window</code> window, it should have a red outline:</p> <p></p> <p>Now right-click on the highlighted row and click \"View Properties\", which brings up the window's property inspector on the right:</p> <p></p> <p>Now right-click again and select \"Messages...\", and move your mouse over the <code>create_window</code> window.  You should see messages flooding in:</p> <p></p> <p>You can filter messages by clicking the filter icon:</p> <p></p> <p>Reduce the signal-to-noise ratio by selectively excluding messages:</p> <p></p> <p>Which will help reveal which events are received and emitted when manipulating a window:</p> <p></p> <p>Spend a few minutes (or hours) playing around.  See what messages are sent when dragging and/or maximizing a window.</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#further-reading_3","title":"Further Reading","text":"<ul> <li>Window Messages (Get Started with Win32 and C++)</li> <li>System-Defined Messages</li> </ul>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#window-procedure","title":"Window Procedure","text":"<p>Window Procedures states:</p> <p>Every window has an associated window procedure \u2014 a function that processes all messages sent or posted to all windows of the class. </p> <p>All aspects of a window's appearance and behavior depend on the window procedure's response to these messages.</p> <p>Seems pretty important, eh?  </p> <p>Yes, the window procedure is the beating heart of the window, where all system-generated messages are eventually delivered to and processed from. </p> <p>Let\u2019s take things for a spin by handling the WM_PAINT and WM_WINDOWPOSCHANGING messages in our window procedure.</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#customizing-our-window","title":"Customizing Our Window","text":"","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#wm_paint","title":"WM_PAINT","text":"<p>The <code>WM_PAINT</code> message indicates that our window needs to be repainted.  By responding to it, we can modify what's drawn to the screen.</p> <p>Let\u2019s do so and add a bit of color to our window.</p> <p>First, replace the <code>use</code> section:</p> main.rs<pre><code>use windows::{\ncore::*, Win32::Foundation::*, Win32::Graphics::Gdi::ValidateRect,\nWin32::System::LibraryLoader::GetModuleHandleA,\nWin32::UI::WindowsAndMessaging::*,\n};\n</code></pre> <p>With:</p> main.rs<pre><code>use windows::{\ncore::*, Win32::Foundation::*, Win32::Graphics::Gdi::*,\nWin32::System::LibraryLoader::GetModuleHandleA, Win32::UI::WindowsAndMessaging::*,\n};\n</code></pre> <p>Then replace the <code>WM_PAINT</code> section in <code>wndproc</code> with:</p> <p>main.rs<pre><code>WM_PAINT =&gt; {\nprintln!(\"WM_PAINT\");\nlet mut msg =  String::from(\"ZOMG!\");\nlet mut ps = PAINTSTRUCT::default();\nlet psp = &amp;mut ps as *mut PAINTSTRUCT;\nlet rp = &amp;mut ps.rcPaint as *mut RECT;\nlet hdc = BeginPaint(window, psp);\nlet brush = CreateSolidBrush(COLORREF(0x0000F0F0));\nFillRect(hdc, &amp;ps.rcPaint, brush);\nDrawTextA(hdc, msg.as_bytes_mut(), rp, DT_SINGLELINE | DT_CENTER | DT_VCENTER );\nEndPaint(window, &amp;ps);\nLRESULT(0)\n}\n</code></pre> - source</p> <p>A <code>cargo run --bin create_window</code> results in:</p> <p></p> <p>Sweet.</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#wm_windowposchanging","title":"WM_WINDOWPOSCHANGING","text":"<p>Raymond Chen gives this example on <code>WM_WINDOWPOSCHANGING</code>, which we can implement by adding the following to <code>wnd_proc</code>:</p> hello\\src\\lib.rs<pre><code>WM_WINDOWPOSCHANGING =&gt; {\nlet data = lparam.0 as *mut WINDOWPOS;\nlet data = data.as_mut().unwrap();\ndata.flags |= SWP_NOSIZE | SWP_NOMOVE;\n}\n</code></pre>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#window-subclassing","title":"Window Subclassing","text":"<p>We now have a basic understanding of how a window works, how its constructed, and how its window procedure affects its presentation and behavior.</p> <p>Yet, our knowledge is limited to changing the appearance of windows that we create or have the source code to.  To do the same for other people's windows (including our own), we need to use a technique called subclassing:</p> <p>Subclassing is a technique that allows an application to intercept and process messages sent or posted to a particular window before the window has a chance to process them. By subclassing a window, an application can augment, modify, or monitor the behavior of the window...</p> <p>Cool, cool.</p> <p>An application subclasses a window by replacing the address of the window's original window procedure with the address of a new window procedure, called the subclass procedure. Thereafter, the subclass procedure receives any messages sent or posted to the window.</p> <p>Ah, got it.</p> <p>...you cannot subclass a window or class that belongs to another application. All subclassing must be performed within the same process.</p> <p>BOOM!  (the crowd goes wild)  </p> <p>See, in Injecting The GD Thing we learned how to inject a DLL into another application's process space. </p> <p>So, in theory, if we could construct a DLL that automatically subclasses an application\u2019s main window.  </p> <p>We could then inject it into another application\u2019s process space.  </p> <p>Which, in theory, would allow us to subclass any window!  </p> <p>So, then, how do we subclass?!</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#setwindowlong","title":"SetWindowLong","text":"<p>\"About Window Procedures\" directs us to SetWindowLong.</p> <p>SetWindowsLong informs us:</p> <p>Note</p> <p>This function has been superseded by the SetWindowLongPtr function. To write code that is compatible with both 32-bit and 64-bit versions of Windows, use the SetWindowLongPtr function.</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#setwindowlongptr","title":"SetWindowLongPtr","text":"<p>SetWindowLongPtr says it: changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory. </p> <p>You use the function like this:</p> SetWindowLongPtrW<pre><code>let prev_wndproc = SetWindowLongPtrW( hwnd,\nGWLP_WNDPROC,\nwnd_proc as isize\n)\n</code></pre> <p>where:</p> <ul> <li><code>hwnd</code>: a handle to the window we want to subclass</li> <li><code>GWLP_WNDPROC</code>: \"Sets a new address for the window procedure\"</li> <li><code>wnd_proc</code>: the replacement window procedure</li> <li><code>prev_wndproc</code>: a pointer to the previous \"window procedure\"</li> </ul>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#replacement-window-procedure","title":"Replacement Window Procedure","text":"<p><code>wnd_proc</code> is simply a \"window procedure\" with one crucial difference: it calls <code>CallWindowProc</code> instead of <code>DefWindowProcW</code>.</p> <pre><code>extern \"system\" fn wnd_proc(\nwindow: HWND,\nmessage: u32,\nwparam: WPARAM,\nlparam: LPARAM,\n) -&gt; LRESULT {\nunsafe {\nmatch message {\n// WM_PAINT =&gt; { }\n_ =&gt; ()\n}\nCallWindowProcW(PREV_WNDPROC, window, message, wparam, lparam)\n}\n}\n</code></pre>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#callwindowproca","title":"CallWindowProcA","text":"<p>CallWindowProc is used to pass messages to the previous window procedure, i.e. <code>prev_wndproc</code>, and remember, we must call <code>CallWindowProcW</code> on any messages we do not process.</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#result","title":"Result","text":"<p>If the function succeeds, it returns a pointer to the previous window procedure.</p> <p>If the function fails, it returns 0.</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#actually-subclassing-a-window","title":"Actually Subclassing A Window","text":"<p>Let's refactor our <code>create_window</code> example to use <code>SetWindowLongPtr</code>.</p> <p>First, let's add our skeleton <code>wnd_proc</code> to <code>main.rs</code>:</p> create_window\\src\\main.rs<pre><code>extern \"system\" fn wnd_proc(\nwindow: HWND,\nmessage: u32,\nwparam: WPARAM,\nlparam: LPARAM,\n) -&gt; LRESULT {\nunsafe {\nmatch message {\n// i.e. WM_PAINT =&gt; { }\n_ =&gt; ()\n}\nCallWindowProcW(PREV_WNDPROC, window, message, wparam, lparam)\n}\n}\n</code></pre> <p>We can immediately see a problem, we've gotta get <code>PREV_WNDPROC</code> into <code>wnd_proc</code>.  Since we're still learning, let's stick a gross global variable above our <code>main</code>:</p> <pre><code>static mut PREV_WNDPROC: WNDPROC = None;\n...\nfn main() -&gt; Result&lt;()&gt; {\n</code></pre> <p>Now, let's update our <code>fn main()</code> to grab the window <code>handle</code> returned by <code>CreateWindowExA</code> and pass it to a <code>SetWindowLongPtrA</code> call:</p> create_window\\main.rs<pre><code>let handle = CreateWindowExA(\n...\nNone,\n);\nlet result = SetWindowLongPtrW(handle, GWLP_WNDPROC, wnd_proc as isize);\nlet prev_wnd_proc = transmute::&lt;isize, WNDPROC&gt;(result);\nlet mut message = MSG::default();\n...\n</code></pre> <p>Finally, let's add this to the top of <code>main.rs</code>:</p> create_window\\main.rs<pre><code>use std::mem::transmute;\n</code></pre> <p>and a <code>cargo check</code> to confirm things compile:</p> <pre><code>$ cargo check\n    Finished dev [unoptimized + debuginfo] target(s) in 0.26s\n</code></pre> <p>Great, now let's tranplant our <code>WM_PAINT</code> into <code>wnd_proc</code>:</p> <pre><code>extern \"system\" fn wnd_proc(\nwindow: HWND,\nmessage: u32,\nwparam: WPARAM,\nlparam: LPARAM,\n) -&gt; LRESULT {\nunsafe {\nmatch message {\nWM_PAINT =&gt; {\nlet mut msg =  String::from(\"ZOMG!\");\nlet mut ps = PAINTSTRUCT::default();\nlet psp = &amp;mut ps as *mut PAINTSTRUCT;\nlet rectp = &amp;mut ps.rcPaint as *mut RECT;\nlet hdc = BeginPaint(window, psp);\nlet brush = CreateSolidBrush(COLORREF(0x0000F0F0));\nFillRect(hdc, &amp;ps.rcPaint, brush);\nDrawTextA(hdc,\nmsg.as_bytes_mut(),\nrectp,\nDT_SINGLELINE | DT_CENTER | DT_VCENTER\n);\nEndPaint(window, &amp;ps);\nreturn LRESULT(0);\n}\nWM_WINDOWPOSCHANGING =&gt; {\nlet data = lparam.0 as *mut WINDOWPOS;\nlet data = data.as_mut().unwrap();\ndata.flags |= SWP_NOSIZE | SWP_NOMOVE;\nreturn LRESULT(0);\n}\nWM_NCDESTROY =&gt; {\nlet result = transmute::&lt;WNDPROC, isize&gt;(PREV_WNDPROC);\nSetWindowLongPtrW(window, GWLP_WNDPROC, result);\nreturn DefWindowProcA(window, message, wparam, lparam);\n}\n_ =&gt; ()\n}\nCallWindowProcW(PREV_WNDPROC, window, msg, wparam, lparam)\n}\n}\n</code></pre> <p>Hitting <code>cargo run --bin create_window</code> yields:</p> <p></p> <p>Doneski!</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#further-reading_4","title":"Further Reading","text":"<ul> <li>Fulgen301/LCTwitch </li> <li>chengyuhui/kdeconnect-rs</li> <li>thisKai/rust-acrylic-demo</li> </ul>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#subclassing-via-dll","title":"Subclassing via DLL","text":"<p>Ok, this is where things start to come together.  Remember how we mentioned that our ultimate goal is to hijack the window of any application via DLL injection?</p> <p>Well, let's start by moving stuff from <code>create_window\\src\\main.rs</code> to <code>hello\\src\\lib.rs</code>.</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#refactoring-create_window","title":"Refactoring create_window","text":"<p>First, add a dependency on the <code>hello</code> crate to <code>create_window's</code> Cargo.toml:</p> Cargo.toml<pre><code>[dependencies]\nhello = { path = \"../hello\" }\n</code></pre> <p>Replacing the <code>SetWindowLongPtr</code> call in <code>create_window\\src\\main.rs</code> with a <code>LoadLibraryA</code> call which loads <code>hello.dll</code>:</p> create_window\\src\\main.rs<pre><code>...\nLoadLibraryA(PCSTR(\"hello.dll\\0\".as_ptr()));\n//let result = SetWindowLongPtrW(handle, GWLP_WNDPROC, wnd_proc as isize);\n//PREV_WNDPROC = transmute::&lt;isize, WNDPROC&gt;(result);\n...\n</code></pre> <p>We can clean-up the <code>use</code> statements:</p> create_window\\src\\main.rs<pre><code>use windows::{\ncore::*,\nWin32::Foundation::*,\nWin32::Graphics::Gdi::*,\nWin32::System::LibraryLoader::{GetModuleHandleA, LoadLibraryA},\nWin32::UI::WindowsAndMessaging::*,\n};\n</code></pre>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#refactoring-hellodll","title":"Refactoring hello.dll","text":"<p>First, let's put our <code>SetWindowLongPtr</code> call into <code>attach</code>:</p> hello\\src\\lib.rs<pre><code>...\nstatic mut PREV_WNDPROC: WNDPROC = None;\n...\nfn attach() {\nunsafe {\nlet result = SetWindowLongPtrW(handle, GWLP_WNDPROC, wnd_proc as isize);\nPREV_WNDPROC = transmute::&lt;isize, WNDPROC&gt;(result);\n};\n}\n</code></pre> <p>While we're on the topic, do we need a <code>detach</code>?  Of course! </p> <pre><code>fn detach() {\nunsafe {\nlet handle = find_window_by_pid(GetCurrentProcessId()).unwrap();\nSetWindowLongPtrW(handle, GWLP_WNDPROC, transmute::&lt;WNDPROC, isize&gt;(PREV_WNDPROC));\n};\n}\n</code></pre> <p>And update <code>DllMain</code>:</p> <pre><code>match call_reason {\nDLL_PROCESS_ATTACH =&gt; attach(),\nDLL_PROCESS_DETACH =&gt; detach(),\n_ =&gt; ()\n}\n</code></pre> <p>Now let's cut-and-paste <code>wnd_proc</code> and stick it under <code>detach</code>:</p> <pre><code>...\nextern \"system\" fn wnd_proc(\nwindow: HWND,\nmessage: u32,\nwparam: WPARAM,\nlparam: LPARAM,\n) -&gt; LRESULT {\nunsafe {\nmatch message {\nWM_PAINT =&gt; {\nlet mut msg =  String::from(\"ZOMG!\");\nlet mut ps = PAINTSTRUCT::default();\nlet psp = &amp;mut ps as *mut PAINTSTRUCT;\nlet rectp = &amp;mut ps.rcPaint as *mut RECT;\nlet hdc = BeginPaint(window, psp);\nlet brush = CreateSolidBrush(COLORREF(0x0000F0F0));\nFillRect(hdc, &amp;ps.rcPaint, brush);\nDrawTextA(hdc,\nmsg.as_bytes_mut(),\nrectp,\nDT_SINGLELINE | DT_CENTER | DT_VCENTER\n);\nEndPaint(window, &amp;ps);\nreturn LRESULT(0);\n}\nWM_WINDOWPOSCHANGING =&gt; {\nlet data = lparam.0 as *mut WINDOWPOS;\nlet data = data.as_mut().unwrap();\ndata.flags |= SWP_NOSIZE | SWP_NOMOVE;\nreturn LRESULT(0);\n}\nWM_NCDESTROY =&gt; {\nlet result = transmute::&lt;WNDPROC, isize&gt;(PREV_WNDPROC);\nSetWindowLongPtrW(window, GWLP_WNDPROC, result);\nreturn DefWindowProcA(window, message, wparam, lparam);\n}\n_ =&gt; ()\n}\nCallWindowProcW(PREV_WNDPROC, window, message, wparam, lparam)\n}\n}\n</code></pre> <p>Things are looking good, except we have one major problem,  <code>SetWindowLongPtr</code> needs a handle to a window to subclass, specifically, for <code>hello.dll</code>, that would be a handle to the main GUI window of the application it's been injected into.</p> <p>However, <code>LoadLibrary</code> doesn't provide a means of passing arguments, so we can't pass it from <code>create_window</code>...  it seems that <code>hello.dll</code> is going to have to dig up the window handle all by itself.</p> <p>Now, this is a challenging problem, so we're going to use something ready baked, however, I'll dissect the code in a follow-up article.</p> <p>Ok, paste the following after <code>wnd_proc</code>:</p> hello\\src\\lib.rs<pre><code>pub fn find_window_by_pid(pid: u32) -&gt; Result&lt;HWND&gt; {\nlet mut data = EnumWindowsData {\nwanted_pid: pid,\nhandle: HWND::default(),\nfound: false,\n};\nunsafe {\nEnumWindows(\nSome(enum_windows_callback),\nLPARAM(&amp;mut data as *mut EnumWindowsData as isize)\n);\n};\nif !data.found {\nreturn Err(Error::new( ErrorKind::NotFound, \"Can't find the window!\"));\n}\nOk(data.handle)\n}\n#[derive(Default)]\nstruct EnumWindowsData {\nwanted_pid: u32,\nhandle: HWND,\nfound: bool,\n}\nunsafe extern \"system\" fn enum_windows_callback(handle: HWND, lparam: LPARAM) -&gt; BOOL {\nlet data = lparam.0 as *mut EnumWindowsData;\nlet mut data = data.as_mut().unwrap();\nlet mut pid = MaybeUninit::&lt;u32&gt;::zeroed();\nGetWindowThreadProcessId(handle, Some(pid.as_mut_ptr()));\nlet pid = pid.assume_init();\nif pid == data.wanted_pid\n&amp;&amp; GetWindow(handle, GW_OWNER).0 == 0\n&amp;&amp; IsWindowVisible(handle).as_bool()\n{\ndata.handle = handle;\ndata.found = true;\nreturn BOOL(0);\n}\nBOOL(1)\n}\n</code></pre> <p>Now, finish up by using <code>find_window_by_pid</code> to satisfy <code>SetWindowLongPtr</code> in <code>attach</code> and <code>detach</code>.</p> <p>After cleaning up our <code>use</code> statements, things should look like:</p> main.rs<pre><code>use windows::{ Win32::Foundation::*, Win32::System::SystemServices::*, };\nuse windows::Win32::System::Threading::GetCurrentProcessId;\nuse windows::{\nWin32::Graphics::Gdi::*,\nWin32::UI::WindowsAndMessaging::*,\n};\nuse std::mem::{transmute, MaybeUninit};\nuse std::io::{Result, Error, ErrorKind};\nstatic mut PREV_WNDPROC: WNDPROC = None;\n#[no_mangle]\n#[allow(non_snake_case, unused_variables)]\nextern \"system\" fn DllMain(\ndll_module: HINSTANCE,\ncall_reason: u32,\n_: *mut ())\n-&gt; bool\n{\nmatch call_reason {\nDLL_PROCESS_ATTACH =&gt; attach(),\nDLL_PROCESS_DETACH =&gt; detach(),\n_ =&gt; ()\n}\ntrue\n}\nfn attach() {\nunsafe {\nlet handle = find_window_by_pid(GetCurrentProcessId()).unwrap();\nlet result = SetWindowLongPtrW(handle, GWLP_WNDPROC, wnd_proc as isize);\nPREV_WNDPROC = transmute::&lt;isize, WNDPROC&gt;(result);\n};\n}\nfn detach() {\nunsafe {\nlet handle = find_window_by_pid(GetCurrentProcessId()).unwrap();\nSetWindowLongPtrW(handle, GWLP_WNDPROC, transmute::&lt;WNDPROC, isize&gt;(PREV_WNDPROC));\n};\n}\nextern \"system\" fn wnd_proc(\nwindow: HWND,\nmsg: u32,\nwparam: WPARAM,\nlparam: LPARAM,\n) -&gt; LRESULT {\nunsafe {\nmatch msg {\nWM_PAINT =&gt; {\nlet mut msg =  String::from(\"ZOMG!\");\nlet mut ps = PAINTSTRUCT::default();\nlet psp = &amp;mut ps as *mut PAINTSTRUCT;\nlet rectp = &amp;mut ps.rcPaint as *mut RECT;\nlet hdc = BeginPaint(window, psp);\nlet brush = CreateSolidBrush(COLORREF(0x0000F0F0));\nFillRect(hdc, &amp;ps.rcPaint, brush);\nDrawTextA(hdc,\nmsg.as_bytes_mut(),\nrectp,\nDT_SINGLELINE | DT_CENTER | DT_VCENTER\n);\nEndPaint(window, &amp;ps);\nreturn LRESULT(1);\n}\nWM_WINDOWPOSCHANGING =&gt; {\nlet data = lparam.0 as *mut WINDOWPOS;\nlet data = data.as_mut().unwrap();\ndata.flags |= SWP_NOSIZE | SWP_NOMOVE;\nreturn LRESULT(0);\n}\nWM_NCDESTROY =&gt; {\nlet result = transmute::&lt;WNDPROC, isize&gt;(PREV_WNDPROC);\nSetWindowLongPtrW(window, GWLP_WNDPROC, result);\nreturn DefWindowProcA(window, message, wparam, lparam);\n}\n_ =&gt; ()\n}\nCallWindowProcW(PREV_WNDPROC, window, msg, wparam, lparam)\n}\n}\npub fn find_window_by_pid(pid: u32) -&gt; Result&lt;HWND&gt; {\nlet mut data = EnumWindowsData {\nwanted_pid: pid,\nhandle: HWND::default(),\nfound: false,\n};\nunsafe {\nEnumWindows(\nSome(enum_windows_callback),\nLPARAM(&amp;mut data as *mut EnumWindowsData as isize)\n);\n};\nif !data.found {\nreturn Err(Error::new( ErrorKind::NotFound, \"Can't find the window!\"));\n}\nOk(data.handle)\n}\n#[derive(Default)]\nstruct EnumWindowsData {\nwanted_pid: u32,\nhandle: HWND,\nfound: bool,\n}\nunsafe extern \"system\" fn enum_windows_callback(handle: HWND, lparam: LPARAM) -&gt; BOOL {\nlet data = lparam.0 as *mut EnumWindowsData;\nlet mut data = data.as_mut().unwrap();\nlet mut pid = MaybeUninit::&lt;u32&gt;::zeroed();\nGetWindowThreadProcessId(handle, Some(pid.as_mut_ptr()));\nlet pid = pid.assume_init();\nif pid == data.wanted_pid\n&amp;&amp; GetWindow(handle, GW_OWNER).0 == 0\n&amp;&amp; IsWindowVisible(handle).as_bool()\n{\ndata.handle = handle;\ndata.found = true;\nreturn BOOL(0);\n}\nBOOL(1)\n}\n</code></pre> <p>Hitting <code>cargo run</code> in the <code>Create Window</code> crate results in:</p> <p></p> <p>Amazing!</p> <p>Our little <code>hello.dll</code> now automatically overrides the window procedure of any application it's loaded into!</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#a-taste-of-dll-injection","title":"A Taste Of DLL Injection","text":"","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#injecting-into-create_windowexe","title":"Injecting into <code>create_window.exe</code>","text":"<p>Let's double-confirm this by: </p> <ul> <li>comment out <code>LoadLibrary</code> in <code>create_window</code></li> <li>do a <code>cargo run --bin create_window</code> </li> <li>inject  <code>hello.dll</code> into <code>create_window.exe</code> using Process Hacker  </li> </ul> <p>Pretty cool, eh? </p> <p>Note: For the subclass to be called, you have to trigger a 'WM_PAINT' message, which can be done by resizing the <code>create_window.exe</code> window.</p>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/creating-a-window-with-rust/index.html#injecting-into-notepadexe","title":"Injecting into <code>notepad.exe</code>","text":"<p>Try injecting <code>hello.dll</code> into <code>notepad.exe</code>.</p> <p>Part 3 is here: Injecting DLLs With Rust</p> <p>Having trouble? The code this series can be found here: peddamat/how-to-create-a-dll-using-rust </p> <code>#rust</code> <code>#dll</code> <code>#howto</code> <code>#windows</code> <code>#win32</code> <code>#windows-rs</code> <code>#programming</code>","tags":["rust","dll","howto","windows","win32","windows-rs","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html","title":"Injecting DLLs With Rust","text":"<p>All right, dear reader.  If you've followed along from [[Creating A DLL With Rust|Part 1]] and [[Creating A Window With Rust|Part 2]], then you know how to:</p> <ul> <li> Create a Windows dynamic-link library (DLL) using Rust</li> <li> Inject DLLs into processes using Process Hacker</li> <li> Inject DLLs into processes using Rust</li> <li> Create application windows using Rust</li> <li> Override a window's behavior using subclassing</li> </ul> <p>In this chapter, we'll tie everything together by injecting <code>hello.dll</code> into a random process using Rust.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#dll-injection","title":"DLL Injection","text":"<p>Googling the term \"dll injection\" results in page after page of bad news; the term is primarily associated with malicious actors.  </p> <p>Wikipedia, however, presents a more neutral description which perfectly encapsulates the spirit in which we'll be approaching the topic:</p> <p>In computer programming, DLL injection is a technique used for running code within the address space of another process by forcing it to load a dynamic-link library.[1] DLL injection is often used by external programs to influence the behavior of another program in a way its authors did not anticipate or intend. - source</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#injection-techniques","title":"Injection Techniques","text":"<p>Process Injection Techniques presents a good overview of the overall DLL injection landscape. </p> <p>3 Effective DLL Injection Techniques for Setting API Hooksprovides implementation details for the two technique's that we'll explore together:</p> <ul> <li>SetWindowsHookEx</li> <li>CreateRemoteThread</li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#setwindowshookex","title":"SetWindowsHookEx","text":"<p>SetWindowsHookEx is a well documented part of the Windows Win32 API, which does what it says...</p> <p>Enables the installation of \"hooks\", aka callback functions, at various points in an application, allowing you to intercept or passively sniff system events received by the hooked application.</p> <p>but wait, there's more!</p> <p>SetWindowsHookEx can be used to inject a DLL into another process... - source...</p> <p>So, if you place your callback function in a DLL, the operating system conveniently loads said DLL into the application's address space.</p> <p>Excellent.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#createremotethread","title":"CreateRemoteThread","text":"<p>CreateRemoteThread is a less well documented part of the Windows Win32 API, summarized:</p> <p>Creates a thread that runs in the virtual address space of another process.</p> <p>Once a \"remote thread\" is running in the application's address space, a mere <code>LoadLibrary()</code> call is all that's required to complete the DLL injection.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#further-reading","title":"Further Reading","text":"<ul> <li>Of what possible legitimate use are functions like CreateRemoteThread, WriteProcessMemory, and VirtualProtectEx?</li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#dll-syringe","title":"dll-syringe","text":"<p>The <code>dll-syringe</code> crate provides a convenient wrapper around <code>CreateRemoteThread</code> enabling us to inject DLLs programmatically, using Rust:</p> dll-syringe Example<pre><code>use dll_syringe::{Syringe, process::OwnedProcess};\n// find target process by name\nlet target_process = OwnedProcess::find_first_by_name(\"ExampleProcess\").unwrap();\n// create a new syringe for the target process\nlet syringe = Syringe::for_process(target_process);\n// inject the payload into the target process\nlet injected_payload = syringe.inject(\"injection_payload.dll\").unwrap();\n// do something else\n// eject the payload from the target (optional)\nsyringe.eject(injected_payload).unwrap();\n</code></pre>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#further-reading_1","title":"Further Reading","text":"<ul> <li>OpenBtyeDev/dll-syringe</li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#hello_injectexe","title":"hello_inject.exe","text":"<p>Let's create a <code>hello_inject</code> crate to take <code>dll-syringe</code> for a whirl:</p> <pre><code>cargo new hello_inject\n</code></pre> <p>After updating the workspace <code>Cargo.toml</code>...</p> Cargo.toml<pre><code>[workspace]\nmembers = [\n\"hello\",\n\"hello_runner\",\n\"create_window\",\n\"hello_inject\"\n]\n</code></pre> <p>And, adding the dependencies to <code>hello.dll</code> and <code>dll-syringe</code> to <code>Cargo.toml</code>:</p> Cargo.toml<pre><code>[dependencies]\nhello = { path = \"../hello\" }\ndll-syringe = \"0.15.0\"\n</code></pre> <p>Do a <code>cargo check</code>:</p> <pre><code>$ cargo check\n   Compiling proc-macro2 v1.0.51\n    ...\n    Checking dll-syringe v0.15.0\nerror[E0554]: `#![feature]` may not be used on the stable release channel\n--&gt; C:\\Users\\me\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\dll-syringe-0.15.0\\src\\lib.rs:2:1\n  |\n2 | #![feature(maybe_uninit_uninit_array, maybe_uninit_slice, linked_list_cursors)]\n| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n</code></pre> <p>This error indicates that <code>dll-syringe</code> uses features that haven't yet made it into the stable version of Rust.  </p> <p>To fix this, we need to install the bleeding edge version of rust, Rust Nightly.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#rust-nightly","title":"Rust Nightly","text":"<p>Rustup installs Rust Nightly in parallel with your existing Rust installation.  </p> <pre><code>rustup install nightly\n</code></pre> <p>To tell cargo to use Rust Nightly, we have to add the <code>+nightly</code> flag to our commands.  For example, <code>cargo check</code> becomes <code>cargo +nightly check</code>:</p> <pre><code>$ cargo +nightly check\n    ...\n    Checking dll-syringe v0.15.0\n    Checking hello_inject v0.1.0 (C:\\...\\hello_inject)\nFinished dev [unoptimized + debuginfo] target(s) in 22.37s\n</code></pre> <p>Of course, this gets annoying fast, so let's set Rust Nightly as default for the rest of this tutorial by using <code>rustup default nightly</code>.</p> <p>This can be reverted using <code>rustup default stable</code>.</p> <pre><code># Set Rust Nightly as default\nrustup default nightly\n\n# Update Rust Nightly to today's release\nrustup update\n\n# Set Rust Stable as default\nrustup default stable\n</code></pre>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#hello_injectexe-cont","title":"hello_inject.exe (cont.)","text":"<p>Ok, using Rust Nightly do a  <code>cargo build</code>, which may throw a few ignorable warnings.</p> <p>Now update <code>main.rs</code> with the following (taken straight from <code>dll-syringe's</code> README.MD):</p> main.rs<pre><code>use dll_syringe::{Syringe, process::OwnedProcess};\nuse std::{thread, time};\nfn main() {\n// find target process by name\nlet target_process =\nOwnedProcess::find_first_by_name(\"create_window.exe\").unwrap();\n// create a new syringe for the target process\nlet syringe = Syringe::for_process(target_process);\n// inject the payload into the target process\nlet injected_payload = syringe.inject(\"target\\\\debug\\\\hello.dll\").unwrap();\nprintln!(\"DLL injected successfully!\");\n// do something else\nlet ten_millis = time::Duration::from_secs(10);\nprintln!(\"Sleeping for 10 secs...\");\nthread::sleep(ten_millis);\n// eject the payload from the target (optional)\nsyringe.eject(injected_payload).unwrap();\n}\n</code></pre> <p>Fire up <code>create_window</code> with a:</p> <pre><code>cargo run --bin create_window\n</code></pre> <p>Open up another terminal and type:</p> <pre><code>$ cargo run --bin hello_inject\n   ...\n   Compiling dll-syringe v0.15.0\n   Compiling hello_inject v0.1.0 (C:\\...\\hello_inject)\nFinished dev [unoptimized + debuginfo] target(s) in 35.35s\n     Running `target\\debug\\hello_inject.exe`\nDLL injected successfully!\nSleeping for 30 secs...\n</code></pre> <p>It works!</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#identifying-targets","title":"Identifying Targets","text":"<p>We are currently using <code>find_first_by_name()</code> to identify our injection target process.</p> <p>This works great for simple apps, like Notepad, but what if we want to target Chrome, famous for spawning each tab in a separate process:</p> <p></p> <p>Luckily, <code>OwnedProcess::</code> also provides the <code>from_pid()</code> method, so if we can figure out a window's process identifier (pid), we can target it.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#by-window-handle","title":"By Window Handle","text":"<p>It would be useful if we could specify targets by their window handle, since this is something we can easily identify using Window Detective:</p> <p></p> <p>If you recall, we used <code>GetWindowThreadProcessId()</code> in <code>hello.dll</code>, as part of the <code>enum_window_callback()</code>.</p> <p>Using that code as a reference, we can write a <code>find_pid_by_hwnd()</code>:</p> <pre><code>fn find_pid_by_hwnd(hwnd: u32) -&gt; u32 {\nlet mut pid = MaybeUninit::&lt;u32&gt;::zeroed();\nunsafe {\nGetWindowThreadProcessId(HWND(hwnd as isize), Some(pid.as_mut_ptr()));\nreturn pid.assume_init();\n};\n}\n</code></pre> <p>And use it like:</p> <pre><code>// find target process window handle\nlet pid = find_pid_by_hwnd(HWND(0x00401B32));\nlet target_process = OwnedProcess::from_pid(pid).unwrap();\n</code></pre>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#by-window-title","title":"By Window Title","text":"<p>Many of the windows we want to target have window titles, for example, \"Untitled - Notepad\":</p> <p></p> <p>Leveraging <code>find_pid_by_hwnd()</code> and FindWindowA we can write <code>find_pid_by_title()</code>:</p> <pre><code>pub fn find_pid_by_title(title: PCSTR) -&gt; u32 {\nlet hwnd = unsafe {\nFindWindowA(None, title)\n};\nreturn find_pid_by_hwnd(hwnd);\n}\n</code></pre> <p>And use it like:</p> <pre><code>// find target process by window title\nlet pid = find_pid_by_title(s!(\"New Tab - Google Chrome\"));\nlet target_process = OwnedProcess::from_pid(pid).unwrap();\n</code></pre>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#handling-bitness","title":"Handling Bitness","text":"<p>The majority of us are running 64-bit Windows on 64-bit processors, however, we still use a surprising number of 32-bit applications.</p> <p>Process Interoperability explains why this matters to us:</p> <p>On 64-bit Windows, a 64-bit process cannot load a 32-bit dynamic-link library (DLL). Additionally, a 32-bit process cannot load a 64-bit DLL. </p> <p>Which means that:</p> <ul> <li>we need to build both 32-bit and 64-bit versions of <code>hello.dll</code></li> <li>we need to detect whether a process is 32-bit or 64-bit and inject the appropriate build of <code>hello.dll</code></li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#build-targets","title":"Build Targets","text":"<p>Rust makes it easy to generate multiple build targets for a crate or an entire workspace.</p> <p>First, you have to add the 32-bit toolchain:</p> <pre><code># Install 32-bit toolchain &amp; target\nrustup target add i686-pc-windows-msvc\n</code></pre> <p>Then, you specify which target to build using:</p> <pre><code># Build 32-bit binaries\ncargo build --target=i686-pc-windows-msvc\n\n# Build 64-bit binaries\ncargo build --target=x86_64-pc-windows-msvc\n</code></pre> <p>Nice, but cumbersome.  </p> <p>Since we only want multiple builds of <code>hello.dll</code>, we can add a <code>[build]</code> target to its <code>Cargo.toml</code> to specify that:</p> Cargo.toml<pre><code>[build]\ntarget = [\"i686-pc-windows-msvc\", \"x86_64-pc-windows-msvc\"]\n</code></pre> <p>Now when we hit <code>cargo build</code>, we get two new folders in our <code>target</code> directory:</p> <pre><code> $ tree -L 2 -a|more\n.\n\u251c\u2500\u2500 debug\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 create_window.exe\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 hello.dll\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 hello_inject.exe\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 hello_runner.exe\n|  ...\n\u251c\u2500\u2500 i686-pc-windows-msvc\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 debug\n\u2514\u2500\u2500 x86_64-pc-windows-msvc\n    \u2514\u2500\u2500 debug\n</code></pre> <p>The first containing 32-bit binaries and the latter containing 64-bit binaries.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#detecting-process-bitness","title":"Detecting Process Bitness","text":"<p>This one is easy, <code>dll-syringe</code> provides the <code>OwnedProcess::is_x64()</code> and <code>OwnedProcess::is_x86()</code> methods which let us identify which is which.</p> <p>Picking <code>is_x64()</code>, we can write:</p> <pre><code>let dll_path = {\nif OwnedProcess::is_x64(&amp;target_process).unwrap() {\n\"target\\\\x86_64-pc-windows-msvc\\\\debug\\\\hello.dll\"\n} else {\n\"target\\\\i686-pc-windows-msvc\\\\debug\\\\hello.dll\"\n}\n};\n...\nlet injected_payload = syringe.inject(dll_path).expect(\"Architecture mismatch!\");\n</code></pre>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#implementing-interopablity","title":"Implementing Interopablity","text":"<p>Now, if you'd done a <code>cargo build</code>, a few moments earlier, you'd have been greeted with a bunch of \"mismatched types\" errors, like:</p> <pre><code>$ cargo build\n   Compiling hello v0.1.0 (C:\\Users\\me\\source\\blog_qa\\hello)\nerror[E0308]: mismatched types\n--&gt; hello\\src\\lib.rs:38:70\n|\n| let result = SetWindowLongPtrW(handle, GWLP_WNDPROC, wnd_proc as isize);\n|              -----------------                       ^^^^^^^^^^^^^^^^^ |                                        expected `i32`, found `isize`\n|              |\n|              arguments to this function are incorrect\n...\n</code></pre> <p>And:</p> <pre><code>error[E0308]: mismatched types\n--&gt; hello\\src\\lib.rs:39:60\n|\n| PREV_WNDPROC = transmute::&lt;isize, WNDPROC&gt;(result);\n|                --------------------------- ^^^^^^ expected `isize`, found `i32`\n|                |\n|                arguments to this function are incorrect\n...\n</code></pre> <p>With the <code>rustc</code> providing advice like:</p> <pre><code>help: you can convert an `i32` to an `isize` and panic if the ... value doesn't fit\n|\n| PREV_WNDPROC = transmute::&lt;isize, WNDPROC&gt;(result.try_into().unwrap());\n|                                                  ++++++++++++++++++++\n</code></pre> <p>Why is this happening?</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#the-problem","title":"The Problem","text":"<p>Well, throughout this series, we've been writing fairly idiomatic Rust, trying to make sure we dot our t's and cross our i's.</p> <p>For example, when writing:</p> <pre><code>let result = SetWindowLongPtrW(handle, GWLP_WNDPROC, wnd_proc);\n</code></pre> <p><code>rust-analyzer</code> screamed:</p> <pre><code>error[E0308]: mismatched types\n--&gt; hello\\src\\lib.rs:38:70\n|\n| let result = SetWindowLongPtrW(hwnd, GWLP_WNDPROC, wnd_proc);\n|              -----------------                     ^^^^^^^^ |              |                                     expected `isize`, found fn item\n|              |\n|              arguments to this function are incorrect\n...\n</code></pre> <p>Cajoling us into explicitly casting <code>wnd_proc as isize</code>, as directed.  </p> <p>However, <code>rust-analyzer</code> generates suggestions based on the currently configured toolchain, which in my case (and probably yours) is 64-bit.</p> <p>Under the hood, <code>windows-rs</code> is doing this:</p> \\src\\Windows\\Win32\\UI\\WindowsAndMessaging\\mod.rs<pre><code>#[cfg(target_pointer_width = \"32\")]\n#[cfg(feature = \"Win32_Foundation\")]\npub use SetWindowLongW as SetWindowLongPtrW;\n</code></pre> <p>The <code>#cfg[...]</code> stuff is called Conditional compilation, the Rust version of <code>#ifdef</code>...</p> <p>... which means that <code>SetWindowLongPtrW</code> is swapped out for <code>SetWindowLongW</code> when compiling for a 32-bit target.</p> <p>But since you've read the documentation, you already saw this:</p> <p>Note</p> <p>Note  To write code that is compatible with both 32-bit and 64-bit versions of Windows, use SetWindowLongPtr. When compiling for 32-bit Windows, SetWindowLongPtr is defined as a call to the SetWindowLong function.</p> \\src\\Windows\\Win32\\UI\\WindowsAndMessaging\\mod.rs<pre><code>#[doc = \"*Required features: ...\"]\n#[cfg(any(target_arch = \"aarch64\", target_arch = \"x86_64\"))]\n#[cfg(feature = \"Win32_Foundation\")]\n#[inline]\npub unsafe fn SetWindowLongPtrW&lt;P0&gt;(hwnd: P0, nindex: ..., dwnewlong: isize) -&gt; isize\nwhere\nP0: ::std::convert::Into&lt;super::super::Foundation::HWND&gt;,\n{\n::windows::core::link ! ( \"user32.dll\"\"system\" fn SetWindowLongPtrW ( hwnd : super::super::Foundation:: HWND , nindex : WINDOW_LONG_PTR_INDEX , dwnewlong : isize \n) -&gt; isize \n);\nSetWindowLongPtrW(hwnd.into(), nindex, dwnewlong)\n}\n#[doc = *Required features: ...\"]\n#[cfg(feature = \"Win32_Foundation\")]\n#[inline]\npub unsafe fn SetWindowLongW&lt;P0&gt;(hwnd: P0, nindex: ..., dwnewlong: i32) -&gt; i32\nwhere\n    P0: ::std::convert::Into&lt;super::super::Foundation::HWND&gt;,\n{\n    ::windows::core::link ! ( \"user32.dll\"\"system\" fn SetWindowLongW ( \n        hwnd : super::super::Foundation:: HWND , \n        nindex : WINDOW_LONG_PTR_INDEX , \n        dwnewlong : i32 \n        ) -&gt; i32 \n    );\n    SetWindowLongW(hwnd.into(), nindex, dwnewlong)\n}\n</code></pre> <p>Since <code>SetWindowLongPtrW</code> uses <code>isize</code> and <code>SetWindowLongW</code> uses <code>i32</code>, we get the <code>type mismatch</code> errors above.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#solutions","title":"Solution(s)","text":"<p>There are two ways to fix our issue:</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#custom-type","title":"Custom Type","text":"<p>We can define a custom type using a <code>#[cfg(any(target_arch = \"aarch64\", target_arch = \"x86_64\"))]</code> macro to toggle it between <code>isize</code> and <code>i32</code>, like this:</p> <p><pre><code>// Work around a difference between the SetWindowLongPtrW API definition\n// in windows-rs on 32-bit and 64-bit Windows.\n#[cfg(any(target_arch = \"x86_64\", target_arch = \"aarch64\"))]\ntype LongPtr = isize;\n#[cfg(not(any(target_arch = \"x86_64\", target_arch = \"aarch64\")))]\ntype LongPtr = i32;\n</code></pre> - source</p> <p>Replacing all <code>isize</code> references with <code>LongPtr</code>, or whatever you name your custom type, for example:</p> <pre><code>let result = SetWindowLongPtrW(handle, GWLP_WNDPROC, wnd_proc as LongPtr);\n</code></pre>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#type-inference","title":"Type Inference","text":"<p>Alternatively, we can use Rust's powerful type inference abilities, which allows <code>rustc</code> to infer the destination type based on contextual clues:</p> <pre><code>let result = SetWindowLongPtrW(handle, GWLP_WNDPROC, wnd_proc as _);\n</code></pre> <p>Here, the <code>as _</code> indicates our type inference request, which <code>rustc</code> can easily do by referencing its signature from <code>...\\WindowsAndMessaging\\mod.rs</code>.</p> <p>Here's another example where inference works:</p> <pre><code>PREV_WNDPROC = transmute::&lt;_, WNDPROC&gt;(result);\n...\n</code></pre>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#bring-it-home","title":"Bring It Home","text":"<p>Go ahead and use type inference to fix each compile error and make sure workspace compiles with both a  <code>cargo build --target=i686-pc-windows-msvc</code> and  a <code>cargo build --target=x86_64-pc-windows-msvc</code>.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#further-reading_2","title":"Further Reading","text":"<ul> <li>Running 32-bit Applications explains how Windows does this using something called WOW64.</li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#the-moment-of-truth","title":"The Moment Of Truth","text":"<p>We are finally ready to see if our project works with both 32-bit and 64-bit applications.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html#testing-32-bit-applications","title":"Testing 32-bit Applications","text":"<p>If you have a 32-bit application in mind, go ahead and use it.  </p> <p>If you need a recommendation, Tera Term is a hand 32-bit application, you can grab a copy here.</p> <p>It looks like:</p> <p></p> <p>It's a single process application, so you can use <code>find_first_by_name()</code> to grab it in <code>hello_inject</code>: </p> <p></p> <p>Here's what my <code>main.rs</code> looks like:</p> hello\\src\\main.rs<pre><code>use dll_syringe::{Syringe, process::*};\nuse windows::{Win32::{UI::WindowsAndMessaging::{GetWindowThreadProcessId, FindWindowA}, Foundation::HWND}, core::PCSTR, s};\nuse std::{thread, time, borrow::BorrowMut, mem::MaybeUninit};\nfn main() {\n// find target process by .exe\nlet target_process =\nOwnedProcess::find_first_by_name(\"ttermpro.exe\").expect(\"Couldn't find process, exiting!\");\nlet dll_path = {\nif OwnedProcess::is_x64(&amp;target_process).unwrap() {\n\"target\\\\x86_64-pc-windows-msvc\\\\debug\\\\hello.dll\"\n} else {\n\"target\\\\i686-pc-windows-msvc\\\\debug\\\\hello.dll\"\n}\n};\n// create a new syringe for the target process\nlet syringe = Syringe::for_process(target_process);\nlet injected_payload = syringe.inject(dll_path).expect(\"Architecture mismatch!\");\nprintln!(\"DLL injected successfully!\");\n// do something else\nlet ten_millis = time::Duration::from_secs(30);\nprintln!(\"Sleeping for 30 secs...\");\nthread::sleep(ten_millis);\n// eject the payload from the target (optional)\nsyringe.eject(injected_payload).unwrap();\n}\nfn find_pid_by_hwnd(hwnd: HWND) -&gt; u32 {\nlet mut pid = MaybeUninit::&lt;u32&gt;::zeroed();\nunsafe {\nGetWindowThreadProcessId(hwnd, Some(pid.as_mut_ptr()));\nreturn pid.assume_init();\n};\n}\npub fn find_pid_by_title(title: PCSTR) -&gt; u32 {\nlet hwnd = unsafe {\nFindWindowA(None, title)\n};\nreturn find_pid_by_hwnd(hwnd);\n}\n</code></pre> <p>Doing a <code>cargo run --bin hello_inject</code> should result in:</p> <pre><code>$ cargo run --bin hello_inject\n    Finished dev [unoptimized + debuginfo] target(s) in 0.47s\n     Running `target\\x86_64-pc-windows-msvc\\debug\\hello_inject.exe`\nDLL injected successfully!\nSleeping for 30 secs...\n</code></pre> <p>Part 4 is here: Production Ready DLL Injection.</p> <p>Having trouble? The code this series can be found here: peddamat/how-to-create-a-dll-using-rust </p> <code>#rust</code> <code>#dll</code> <code>#howto</code> <code>#windows</code> <code>#programming</code>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html","title":"Production Ready DLL Injection","text":"<p>Dear reader, if you haven't, already, please catch up on [[Creating A DLL With Rust|Part 1]], [[Creating A Window With Rust|Part 2]], and [[Injecting DLLs With Rust|Part 3]] and come back here.  It'll be worth it.  </p> <p>Everyone else, here's what we've covered:</p> <ul> <li> Create a Windows dynamic-link library (DLL) using Rust</li> <li> Inject DLLs into processes using Process Hacker</li> <li> Inject DLLs into processes using Rust</li> <li> Create application windows using Rust</li> <li> Override a window's behavior using subclassing</li> </ul> <p>In today's episode, we'll focus on making our DLL \"production-ready\", by RTFM'ing, adding logging, improving error handling, and, oh yeah, re-writing the whole thing. </p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#read-the-fscking-manual","title":"Read The Fscking Manual","text":"<p>As a believer in Minimalist Instruction , I've focused on getting your hands dirty as quickly as possible.</p> <p>However, DLL injection and window subclassing are extraordinarily powerful and invasive tools, which both transcend traditional operating systems process boundaries; boundaries specifically created to protect running applications from poorly written and/or malicious code.</p> <p>Implementing these sorts of things relying solely on a tutorial, without, studying the underlying system documentation, is a mistake.</p> <p>To see what I mean, let's read some fscking manuals, starting with, <code>SetWindowLongPtr()</code>.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#setwindowlongptr","title":"SetWindowLongPtr","text":"<p>I was serious, go ahead and read it: here</p> <p>It starts with an easy one:</p> <p>The SetWindowLongPtr function fails if the process that owns the window specified by the hWnd parameter is at a higher process privilege in the UIPI hierarchy than the process the calling thread resides in.</p> <p>Basically, we can't subclass apps running as \"Administrator\" if we're a normal user.  This isn't surprising, but can we proactively check and/or inform the user of workarounds?</p> <p>Windows XP/2000:   The SetWindowLongPtr function fails if the window specified by the hWnd parameter does not belong to the same process as the calling thread.</p> <p>This shouldn't be an issue, but good to know if we get a support email.</p> <p>If you use SetWindowLongPtr with the GWLP_WNDPROC index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the WindowProc callback function.</p> <p>Good, we covered this in Creating A Window With RustCallback Function.</p> <p>Calling SetWindowLongPtr with the GWLP_WNDPROC index creates a subclass of the window class used to create the window. </p> <p>Perfect, that's what we did.</p> <p>An application can subclass a system class, but should not subclass a window class created by another process. </p> <p>lol.</p> <p>The SetWindowLongPtr function creates the window subclass by changing the window procedure associated with a particular window class, causing the system to call the new window procedure instead of the previous one. </p> <p>Sketching this out, we have a Window with a default window procedure:</p> <p></p> <p>After a <code>SetWindowLongPtr()</code>, the default window procedure is replaced with our new window procedure's address.</p> <p>The new window procedure calls <code>DefWindowProcW()</code>to hand-off unprocessed messages to the default window procedure:</p> <p></p> <p>Makes sense.</p> <p>An application must pass any messages not processed by the new window procedure to the previous window procedure by calling CallWindowProc. This allows the application to create a chain of window procedures.</p> <p>Parsing this out fully:</p> <ul> <li>if we don't process the message, then we must hand-off to previous window procedure</li> <li>if we do process a message, we can choose whether to return or to hand it off</li> </ul> <p>Got it.</p> <p>About Window Procedures mentions:</p> <p>The application must also have the original window procedure address to remove the subclass from the window. To remove the subclass, the application calls SetWindowLong again, passing the address of the original window procedure with the GWL_WNDPROC flag and the handle to the window.</p> <p>Removing a subclass using <code>prev_wndproc</code> is straightforward.  We just need to make sure we hold onto it.</p> <p>When an application subclasses a subclassed window, it must remove the subclasses in the reverse order they were performed. If the removal order is not reversed, an unrecoverable system error may occur.</p> <p>Considering the case where we subclass a window twice, for whatever reason, we need to unsubclass in the reverse order:</p> <pre><code># Subclassing\nlet one = SetWindowLongPtr(a, ...)\nlet two = SetWindowLongPtr(b, ...)\n# Unsubclassing\nSetWindowLongPtr(two, ...); // returns b\nSetWindowLongPtr(one, ...); // returns a\n</code></pre> <p>\ud83d\udc4d</p> <p>In Homework assignment about window subclassing and  Safer subclassing warns:</p> <p>One gotcha that isn\u2019t explained clearly in the documentation is that you must remove your window subclass before the window being subclassed is destroyed. This is typically done either by removing the subclass once your temporary need has passed, or if you are installing a permanent subclass, by inserting a call to RemoveWindowSubclass inside the subclass procedure itself: </p> <pre><code>...\ncase WM_NCDESTROY:\nRemoveWindowSubclass(hwnd, thisfunctionname, uIdSubclass);\nreturn DefSubclassProc(...);\n</code></pre> <p>So, if the user unexpectedly closes a window that we've subclassed, we must remove our subclass when we receive the <code>WM_NCDESTROY</code> message (which is actually the very last message the system sends us before terminating the window).</p> <p>Do not assume that subclasses are added and removed in a purely stack-like manner. If you want to unsubclass and find that you are not the window procedure at the top of the chain you cannot safely unsubclass. You will have to leave your subclass attached until it becomes safe to unsubclass. Until that time, you just have to keep passing the messages through to the previous procedure. </p> <p>So, when removing a subclass (by calling <code>SetWindowLongPtr</code> with <code>prev_wndproc</code>), we have to somehow determine if anyone has subclassed the same window after us, and if so, wait until <code>WM_NCDESTROY</code> to remove our subclass.</p> <p>This one's a doozy, so let's sketch it out, starting with out default window procedure:</p> <p></p> <p>After a <code>SetWindowLongPtr()</code>, the default window procedure is replaced with our new window procedure's address:</p> <p></p> <p>At some point before we unsubclass ourselves, someone else calls <code>SetWindowLongPtr()</code> and replaces our window procedure, with theirs.  </p> <p>Of course, they think our window procedure is the default window procedure, so they squirrel it away for safe keeping.</p> <p>Hopefully, they're handing-off unprocessed messages using <code>DefWindowProcW()</code>, in which case, our window procedure receives those messages:</p> <p></p> <p>Then, if we decide to unsubclass before they unsubclass, by calling <code>SetWindowLongPtr()</code> with our <code>prev_wndproc</code>, we end up accidentally unsubclassing them as well:</p> <p></p> <p>Oy vey.</p> <p>So, it's actually easy to check if someone's subclassed after us by calling <code>GetWindowLongPtr()</code>, and comparing what's returned against <code>prev_wndproc</code>. </p> <p>But that's rife with race conditions, and probably (definitely) requires locks and mutexes and \ud83e\udd2e</p> <p>And, even if we get that sorted, how do we get <code>0xCCC</code> to call <code>0xAAA</code>, instead of our removed subclass procedure?</p> <p>Yeah, Raymond's basically saying that we're trapped until <code>WM_NCDESTROY</code> if someone subclasses after us...</p> <p></p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#conclusions","title":"Conclusions","text":"<p>After wading through all that <code>SetWindowLongPtr</code> documentation and errata, it feels like we've hit some really insurmountable issues; unless we're ok with leaving DLLs dangling around, potentially forever, if we get subclassed.</p> <p>Fortunately, Raymond gives us a glimmer of hope, SetWindowSubclass, which we'll explore next.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#further-reading","title":"Further reading","text":"<ul> <li>What is the difference between WM_DESTROY and WM_NCDESTROY?</li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#setwindowsubclass","title":"SetWindowSubclass","text":"<p>Let's start by reading the documentation: here</p> <p>Everything seems great until we get to this warning:</p> <p>Warning</p> <p>You cannot use the subclassing helper functions to subclass a window across threads.</p> <p>From our earlier <code>SetWindowLongPtr</code> experiments, we saw that DllMain is called from the same process but a different thread than the main GUI thread.</p> <p>If we want to use SetWindowSubclass, we'll have to work around this.</p> <p>Let's get our hands dirty by refactoring <code>create_window</code> to use <code>SetWindowSubclass</code> instead of <code>SetWindowLongPtr</code>.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#refactoring-create_windowexe","title":"Refactoring create_window.exe","text":"<p>First, replace the existing calls with:</p> <pre><code>//LoadLibraryA(PCSTR(\"hello.dll\\0\".as_ptr()));\n//let result = SetWindowLongPtrW(handle, GWLP_WNDPROC, wnd_proc as isize);\n//PREV_WNDPROC = transmute::&lt;isize, WNDPROC&gt;(result);\nSetWindowSubclass(handle, Some(wnd_proc), 0, 0);\n</code></pre> <p>Copy over <code>wnd_proc</code> from <code>lib.rs</code>:</p> lib.rs<pre><code>extern \"system\" fn wnd_proc(\nwindow: HWND,\nmessage: u32,\nwparam: WPARAM,\nlparam: LPARAM,\n_: usize,\n_: usize,\n) -&gt; LRESULT {\nunsafe {\nmatch message {\nWM_PAINT =&gt; {\nlet mut msg =  String::from(\"ZOMG!\");\nlet mut ps = PAINTSTRUCT::default();\nlet psp = &amp;mut ps as *mut PAINTSTRUCT;\nlet rectp = &amp;mut ps.rcPaint as *mut RECT;\nlet hdc = BeginPaint(window, psp);\nlet brush = CreateSolidBrush(COLORREF(0x0000F0F0));\nFillRect(hdc, &amp;ps.rcPaint, brush);\nDrawTextA(hdc,\nmsg.as_bytes_mut(),\nrectp,\nDT_SINGLELINE | DT_CENTER | DT_VCENTER\n);\nEndPaint(window, &amp;ps);\nreturn LRESULT(0);\n}\nWM_WINDOWPOSCHANGING =&gt; {\nlet data = lparam.0 as *mut WINDOWPOS;\nlet data = data.as_mut().unwrap();\ndata.flags |= SWP_NOSIZE | SWP_NOMOVE;\nreturn LRESULT(0);\n}\nWM_NCDESTROY =&gt; {\n// let result = transmute::&lt;WNDPROC, _&gt;(PREV_WNDPROC);\n// SetWindowLongPtrW(window, GWLP_WNDPROC, result);\nRemoveWindowSubclass(window, Some(wnd_proc), 0);\nreturn DefWindowProcA(window, message, wparam, lparam);\n}\n_ =&gt; ()\n}\n// CallWindowProcW(PREV_WNDPROC, window, message, wparam, lparam)\nDefSubclassProc(window, message, wparam, lparam)\n}\n}\n</code></pre> <p>Doing a <code>cargo run --bin create_window</code> should have a few unused import warnings, but yield a:</p> <p></p> <p>Well, that was pretty easy!</p> <p>Now let's do the same with <code>lib.rs</code>:</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#refactoring-hellodll","title":"Refactoring hello.dll","text":"<p>Do stuff...</p> <p><code>cargo run --bin create_window</code> results in:</p> <p></p> <p>Yay!</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#hello_inject","title":"hello_inject","text":"<p><code>cargo run --bin hello_inject</code> doesn't work.  Why?</p> <p>To understand, let's talk about Debugging.</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#further-reading_1","title":"Further Reading","text":"<ul> <li>SetWindowSubclass</li> <li>Subclassing Controls</li> <li>Window Procedure Subclassing</li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#debugging","title":"Debugging","text":"<p>Debugging DLLs in any language isn't amazing.  Debugging DLLs in Rust is... rudimentary.  Let's explore our options, starting with, logging!</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#logging","title":"Logging","text":"<p>Up until know we've been able to eyeball success vs failure as we're doing stuff with visible side effects.</p> <p>Now that we've reached the part where...  we're going to need to log.</p> <p>Luckily, the <code>simple-logger</code> crate offers drop-dead simple logging.  Add it to the <code>hello.dll</code> crate with a:</p> <pre><code>cargo add log simple-logger --package hello\n</code></pre> <p>And add this to <code>lib.rs</code>:</p> hello\\src\\lib.rs<pre><code>use log::{LevelFilter, info};\nfn attach() {\nunsafe {\nsimple_logging::log_to_file(\"C:\\\\temp\\\\hello.dll.log\", LevelFilter::Info);\nlet handle = find_window_by_pid(GetCurrentProcessId()).unwrap();\nlet result = SetWindowLongPtrW(handle, GWLP_WNDPROC, wnd_proc as isize);\nPREV_WNDPROC = transmute::&lt;isize, WNDPROC&gt;(result);\n};\n}\n</code></pre>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#tracing","title":"Tracing","text":"","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#process-monitor","title":"Process Monitor","text":"","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#setwindowsubclass-cont","title":"SetWindowSubclass (cont.)","text":"<p>Now that we're certain that <code>SetWindowSubclass</code> is not going to work across threads... we need to figure out how to call <code>SetWindowSubclass</code> from our window's GUI thread.</p> <p>Enter this nugget from Raymond Chen:</p> <p>Recall that when an event occurs on a thread, the window hook is called from the same thread that the event occurred on. For example, a WH_CALL\u00adWND\u00adPROC hook procedure is called when a window procedure is about to be called, and the call occurs on the thread that is about to call the window procedure. ... Anyway, if you have a window hook that can be installed per-thread, then it will be installed only for events on that thread. In the above example, it means that only window procedures on that thread will trigger the hook.  - source: What does the thread parameter to Set\u00adWindows\u00adHook\u00adEx actually mean?</p>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#setwindowshookex","title":"SetWindowsHookEx","text":"<p>Let's start by reading SetWindowHookEx.</p> <p>Great, now let's start refactoring <code>hello.dll</code>, starting with <code>attach()</code>:</p> hello\\src\\lib.rs<pre><code>let gui_tid = GetWindowThreadProcessId(handle, None);\nlet hook = SetWindowsHookExA(\nWH_CALLWNDPROC, Some(call_wnd_proc), None, gui_tid );\n</code></pre> <p>Now let's add <code>call_wnd_proc</code> below <code>attach</code>:</p> hello\\src\\lib.rs<pre><code>#[no_mangle]\nunsafe extern \"system\" fn call_wnd_proc(n_code: i32, w_param: WPARAM, l_param: LPARAM) -&gt; LRESULT {\nif HC_ACTION as i32 == n_code {\nlet origin = w_param.0 as u32;\nlet param = unsafe { *(l_param.0 as *const CWPSTRUCT) };\nmatch param.message {\nWM_SIZING =&gt; info!(\"CallWndProc: Received WM_SIZING\"),\nWM_PAINT =&gt; {\ninfo!(\"CallWndProc: Received WM_PAINT\");\nSetWindowSubclass(param.hwnd, Some(wnd_proc), 0, GUI_TID as _\n);\n},\n_ =&gt; ()\n};\n}\nCallNextHookEx(HHOOK::default(), n_code, w_param, l_param)\n}\n</code></pre>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#further-reading_2","title":"Further Reading","text":"<ul> <li>Explains DLL-based Implementation</li> <li>What is the HINSTANCE passed to SetWindowsHookEx used for?</li> <li>Why does SetWindowsHookEx take an HINSTANCE parameter?</li> <li>One way people abused hooks in 16-bit Windows</li> </ul>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#createthread","title":"CreateThread","text":"<p>Read CreateThread.</p> <p>The ExitProcess, ExitThread, CreateThread, CreateRemoteThread functions, and a process that is starting (as the result of a CreateProcess call) are serialized between each other within a process. Only one of these events can happen in an address space at a time. This means the following restrictions hold:</p> <pre><code>- During process startup and DLL initialization routines, new threads can be created, but they do not begin execution until DLL initialization is done for the process.\n- Only one thread in a process can be in a DLL initialization or detach routine at a time.\n- ExitProcess does not return until no threads are in their DLL initialization or detach routines.\n</code></pre> <ul> <li>source</li> </ul> <p>Let's refactor <code>attach()</code> so that it creates a new thread:</p> hello\\src\\lib.rs<pre><code>fn attach() {\nunsafe {\nTHREAD_HANDLE = CreateThread(\nNone, 0, Some(worker_thread), None, THREAD_CREATION_FLAGS(0), None);\n}\ninfo!(\"Finished hooking!\");\n}\n</code></pre> <p>And let's create <code>worker_thread()</code>:</p> hello\\src\\lib.rs<pre><code>unsafe extern \"system\" fn worker_thread(_data: *mut std::ffi::c_void) -&gt; u32 {\nunsafe {\nlet handle = find_window_by_pid(GetCurrentProcessId()).unwrap();\nGUI_TID = GetWindowThreadProcessId(handle, None);\nlet logfile = format!(\"C:\\\\Users\\\\me\\\\source\\\\blog_qa\\\\hello.log\");\nsimple_logging::log_to_file(logfile, LevelFilter::Info);\ninfo!(\"hello.dll attached - tid: {} / pid: {} / target tid: {}\",\nGetCurrentThreadId(),\nGetCurrentProcessId(),\nGUI_TID\n);\nlet hook = SetWindowsHookExA(\nWH_CALLWNDPROC, Some(call_wnd_proc), None, GUI_TID);\nHOOKS.push(hook);\nwhile true {\nthread::sleep(time::Duration::from_secs(100));\n};\n};\n</code></pre>","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#production-readiness","title":"Production Readiness","text":"","tags":["rust","dll","howto","windows","programming"]},{"location":"guides/window-hacking-with-rust/production-ready-dll-injection/index.html#error-handling","title":"Error Handling","text":"<code>#rust</code> <code>#dll</code> <code>#howto</code> <code>#windows</code> <code>#programming</code>","tags":["rust","dll","howto","windows","programming"]},{"location":"notes/index.html","title":"Notes","text":"<p>{{ blog_content notes }}</p>"},{"location":"notes/modern-debugging-tools-for-windows/index.html","title":"Modern Debugging Tools For Windows","text":""},{"location":"notes/modern-debugging-tools-for-windows/index.html#tracing","title":"Tracing","text":""},{"location":"notes/modern-debugging-tools-for-windows/index.html#api-monitor-rohitabcom","title":"API Monitor (rohitab.com)","text":"<ul> <li>API Monitor is a powerful debugging tool used by software developers to monitor and debug API calls made by their applications.</li> <li>The tool is developed and maintained by Rohitab Batra, a software engineer and security researcher.</li> <li>API Monitor supports monitoring of over 1,300 different API functions, including functions in Windows operating systems, third-party libraries, and custom APIs.</li> <li>The tool allows developers to view detailed information about API calls, such as the parameters passed to the function and the return values.</li> <li>With API Monitor, developers can quickly identify and diagnose issues with their applications by analyzing the behavior of the API calls made by the application.</li> </ul>"},{"location":"notes/modern-debugging-tools-for-windows/index.html#dependency-analysis","title":"Dependency Analysis","text":""},{"location":"notes/modern-debugging-tools-for-windows/index.html#dll-export-viewer","title":"DLL Export Viewer","text":"<ul> <li>link</li> </ul>"},{"location":"notes/modern-debugging-tools-for-windows/index.html#debugview","title":"DebugView","text":"<ul> <li>link</li> </ul>"},{"location":"notes/modern-debugging-tools-for-windows/index.html#dependencies","title":"Dependencies","text":"<ul> <li>link</li> </ul>"},{"location":"notes/modern-debugging-tools-for-windows/index.html#process-hacker","title":"Process Hacker","text":"<ul> <li>link</li> </ul>"},{"location":"notes/modern-debugging-tools-for-windows/index.html#processexplorer","title":"ProcessExplorer","text":"<ul> <li>link</li> </ul>"},{"location":"notes/modern-debugging-tools-for-windows/index.html#processmonitor","title":"ProcessMonitor","text":"<ul> <li>link</li> </ul>"},{"location":"notes/modern-debugging-tools-for-windows/index.html#dependency-walker","title":"Dependency Walker","text":"<ul> <li>link</li> </ul>"},{"location":"notes/modern-debugging-tools-for-windows/index.html#x64dbg","title":"x64dbg","text":"<ul> <li>link</li> </ul>"},{"location":"notes/modern-debugging-tools-for-windows/index.html#hex-editors","title":"Hex Editors","text":""},{"location":"notes/modern-debugging-tools-for-windows/index.html#imhex","title":"ImHex","text":""},{"location":"notes/modern-debugging-tools-for-windows/index.html#other","title":"Other","text":""},{"location":"notes/modern-debugging-tools-for-windows/index.html#wifiinfoview","title":"wifiinfoview","text":""},{"location":"notes/modern-debugging-tools-for-windows/index.html#microcontroller","title":"Microcontroller","text":"<p>DSView.lnk J-Link Commander V7.84c.lnk' MPLAB ICD3 Driver Switcher.lnk' MPLAB IPE v6.05.lnk' MPLAB X IDE v6.05.lnk' Meld.lnk PlatformIO Projects.lnk' PulseView.lnk SQLiteStudio UsbDriverTool</p>"},{"location":"notes/debug-probes/black-magic-probe/index.html","title":"Black Magic Probe","text":"","tags":["wip"]},{"location":"notes/debug-probes/black-magic-probe/index.html#diy-probe","title":"DIY Probe","text":"","tags":["wip"]},{"location":"notes/debug-probes/black-magic-probe/index.html#compile-firmware","title":"Compile Firmware","text":"<pre><code>sudo apt-get install gcc-arm-none-eabi\ngit clone https://github.com/blacksphere/blackmagic.git\ncd blackmagic &amp;&amp; make -j4\ncd src &amp;&amp; make clean &amp;&amp; make PROBE_HOST=stlink\n</code></pre>","tags":["wip"]},{"location":"notes/debug-probes/black-magic-probe/index.html#program-stm32f103-board","title":"Program STM32F103 Board","text":"<p>\u2022 Install latest dfu-util: http://dfu-util.sourceforge.net/releases/</p> <pre><code>$ dfu-util.exe -d 0x1eaf:0x0003 -a 1 -D C:\\...\\AppData\\Local\\Temp\\arduino_...\\HelloWorld.ino.bin\n</code></pre>","tags":["wip"]},{"location":"notes/debug-probes/black-magic-probe/index.html#references","title":"References","text":"<ul> <li>Converting an STM32F103 board to a Black Magic Probe</li> <li>https://github.com/blacksphere/blackmagic/wiki</li> <li>https://github.com/blacksphere/blackmagic/wiki/Hacking</li> </ul> <code>#wip</code>","tags":["wip"]},{"location":"notes/debug-probes/segger-j-link/index.html","title":"Segger J-Link","text":"","tags":["wip"]},{"location":"notes/debug-probes/segger-j-link/index.html#j-link-base-v10","title":"J-Link BASE V10","text":"","tags":["wip"]},{"location":"notes/debug-probes/segger-j-link/index.html#pinout","title":"Pinout","text":"","tags":["wip"]},{"location":"notes/debug-probes/segger-j-link/index.html#supported-features","title":"Supported Features","text":"<ul> <li>link</li> </ul>","tags":["wip"]},{"location":"notes/debug-probes/segger-j-link/index.html#j-link-edu-mini-v1","title":"J-Link EDU Mini V1","text":"","tags":["wip"]},{"location":"notes/debug-probes/segger-j-link/index.html#supported-features_1","title":"Supported Features","text":"<ul> <li>link</li> </ul>","tags":["wip"]},{"location":"notes/debug-probes/segger-j-link/index.html#configuring-j-link-for-platformio","title":"Configuring J-Link For PlatformIO","text":"<p>Adafruit Feather M0 SWD Debugging</p> <ul> <li>Use UsbDriverTool to confirm native driver is installed:     </li> </ul> <p>\u2022 Update platformio.ini: <pre><code>debug_tool = jlink\ndebug_speed = 1200\n</code></pre></p> <p></p> <p>From https://docs.platformio.org/en/stable/plus/debug-tools/jlink.html </p> <p></p> <code>#wip</code>","tags":["wip"]},{"location":"notes/development-kits/adafruit-feather-m0-wifi/index.html","title":"Adafruit Feather M0 WiFi","text":"","tags":["wip"]},{"location":"notes/development-kits/adafruit-feather-m0-wifi/index.html#pinout","title":"Pinout","text":"","tags":["wip"]},{"location":"notes/development-kits/adafruit-feather-m0-wifi/index.html#arduino-setup","title":"Arduino Setup","text":"<ol> <li>Add this URL to \"Additional Boards Manasger URLs\":  <ul> <li>https://adafruit.github.io/arduino-board-index/package_adafruit_index.json </li> </ul> </li> <li>Install \"Adafruit SAMD boards\" package </li> <li>Install \"Arduino SAMD Boards\" package - Reference</li> </ol> <p>Sketches using the WiFi101 Library Must Include The Following</p> <pre><code>WiFi.setPins(8,7,4,2);\n</code></pre>","tags":["wip"]},{"location":"notes/development-kits/adafruit-feather-m0-wifi/index.html#schematic","title":"Schematic","text":"","tags":["wip"]},{"location":"notes/development-kits/adafruit-feather-m0-wifi/index.html#links","title":"Links","text":"<ul> <li>User Manual</li> <li>User Manual (pdf) </li> </ul> <code>#wip</code>","tags":["wip"]},{"location":"notes/development-kits/esp32/index.html","title":"ESP32","text":"","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#helpful-links","title":"Helpful Links","text":"<ul> <li>ESP32 Pinout Reference</li> <li>Low-cost ESP32 In-circuit Debugging</li> </ul> ESP32 Pinout Reference","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#esp32-wroom32-module","title":"ESP32 WROOM32 Module","text":"","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#esp32-wroom","title":"ESP32-WROOM","text":"","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#pinout","title":"Pinout","text":"","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#loading-micropython","title":"Loading MicroPython","text":"<ol> <li>Download firmware from: https://micropython.org/download/esp32/</li> <li>Burn firmware using: https://adafruit.github.io/Adafruit_WebSerial_ESPTool/<ul> <li>Offset is 0x1000</li> </ul> </li> <li>Reset board and connect to serial port using Putty</li> <li>Type following:</li> </ol> <pre><code>from machine import Pin\nled = Pin(2, Pin.OUT)\nled.value(1)\n</code></pre> <p>Additional information: https://docs.micropython.org/en/latest/esp32/general.html</p>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#esp32-cam","title":"ESP32-CAM","text":"","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#pinout_1","title":"Pinout","text":"","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#loading-micropython_1","title":"Loading MicroPython","text":"<ol> <li>Download firmware from: https://micropython.org/download/esp32/</li> <li>Erase flash completely</li> <li>Burn firmware using: https://adafruit.github.io/Adafruit_WebSerial_ESPTool/     \u25cb Offset is 0x1000</li> <li>Reset board and connect to serial port using Putty</li> <li>Type following: <pre><code>from machine import Pin\nled = Pin(4, Pin.OUT)\nled.value(1)\n</code></pre></li> </ol>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#loading-circuitpython","title":"Loading CircuitPython","text":"<ol> <li>Download firmware from: https://circuitpython.org/board/espressif_esp32_eye/</li> <li>Erase flash completely</li> <li>Burn firmware using: https://adafruit.github.io/Adafruit_WebSerial_ESPTool/     \u25cb Offset is 0x0</li> <li>Reset board and connect to serial port using Putty</li> <li>Type following: <pre><code>from machine import Pin\nled = Pin(4, Pin.OUT)\nled.value(1)\n</code></pre></li> </ol>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#developing-in-vscode","title":"Developing in VSCode","text":"<ul> <li>Set Anaconda prompt as default terminal: </li> </ul> <p>\u2022 mpremote mount . \u2022 Use 'execfile(\"filename.py\")' to run code</p> <p></p>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#jtag-debugging","title":"JTAG Debugging","text":"","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#segger-j-link","title":"Segger J-Link","text":"<p>Note: See Segger J-Link for additional information.</p>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#software-setup","title":"Software Setup","text":"<ol> <li>Download 'USB Driver Tool' from: https://visualgdb.com/UsbDriverTool/</li> <li>Change Jlink driver to WinUSB</li> <li></li> </ol>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#wiring","title":"Wiring","text":"<p>Here's what it looks like when the J-Link is correctly connected: <pre><code>$ cd C:\\...\\.platformio\\packages\\tool-openocd-esp32\\bin&gt;\n$ openocd -f ..\\share\\openocd\\scripts\\interface\\jlink.cfg -f ..\\share\\openocd\\scripts\\target\\esp32.cfg -c \"adapter speed 1000\"\n</code></pre></p> <p></p>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#arduino-esp32-library","title":"Arduino-ESP32 Library","text":"","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#setup","title":"Setup","text":"<ol> <li>Install VSCode extension: https://github.com/espressif/vscode-esp-idf-extension/blob/master/docs/tutorial/install.md</li> <li>Follow instructions from: Arduino as an ESP-IDF component</li> </ol>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#command-line-snippets","title":"Command Line Snippets","text":"","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#openocd","title":"OpenOCD","text":"<pre><code># Setup\ncd C:\\...\\.platformio\\packages\\tool-openocd-esp32&gt;\nbin\\openocd -f share\\openocd\\scripts\\interface\\jlink.cfg -f share\\openocd\\scripts\\target\\esp32.cfg -c \"adapter speed 1000\"\n# Erasing Flash\n-c \"init; reset halt; flash erase_address 0x1000 4096000; exit\"\n# Programming Binary\n-c \"program c:\\\\...\\\\esp32-20220618-v1.19.1.bin 0x1000 verify exit\"\n</code></pre>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#rshell","title":"RShell","text":"<p>In an Anaconda Prompt, type the following: <code>.local/bin/rshell -p /dev/ttyS5 -b 115200</code></p>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#esptool","title":"ESPTool","text":"<p>\u2022 Flashing Firmware:  <code>esptool --chip esp32 --port /dev/ttyUSB0 write_flash -z 0x1000 esp32-idf3-20200902-v1.13.bin</code></p>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#esp-idf","title":"ESP-IDF","text":"","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#examples","title":"Examples","text":"<ul> <li>ESP-IDF: Show Examples Projects</li> </ul>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#console","title":"Console","text":"<p>ESP-IDF provides console component, which includes building blocks needed to develop an interactive console over serial port. This component includes following facilities:</p> <ul> <li>Line editing, provided by linenoise library. This includes handling of backspace and arrow keys, scrolling through command history, command auto-completion, and argument hints.</li> <li>Splitting of command line into arguments.</li> <li>Argument parsing, provided by argtable3 library. This library includes APIs used for parsing GNU style command line arguments.</li> <li>Functions for registration and dispatching of commands.</li> <li>Functions to establish a basic REPL (Read-Evaluate-Print-Loop) environment.</li> </ul> <p>From https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/console.html </p>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/esp32/index.html#arduino-usage","title":"Arduino Usage","text":"<p>This Arduino library wraps the ESP-IDF console: https://github.com/jbtronics/ESP32Console</p> <p></p> <code>#uc</code> <code>#esp32</code> <code>#arduino</code>","tags":["uc","esp32","arduino"]},{"location":"notes/development-kits/raspberry-pi/index.html","title":"Raspberry Pi","text":"","tags":["wip"]},{"location":"notes/development-kits/raspberry-pi/index.html#jtag-notes","title":"JTAG Notes","text":"","tags":["wip"]},{"location":"notes/development-kits/raspberry-pi/index.html#connecting-an-nrf24l01-module","title":"Connecting an NRF24L01 Module","text":"","tags":["wip"]},{"location":"notes/development-kits/raspberry-pi/index.html#pins","title":"Pins","text":"","tags":["wip"]},{"location":"notes/development-kits/raspberry-pi/index.html#references","title":"References","text":"<ul> <li>https://github.com/VaclavSynacek/RF24SN</li> <li>https://github.com/VaclavSynacek/RF24SN_CPP_Server </li> </ul> <code>#wip</code>","tags":["wip"]},{"location":"notes/development-kits/esp8266/index.html","title":"Index","text":"","tags":["uc","esp8266"]},{"location":"notes/development-kits/esp8266/index.html#handy-links","title":"Handy Links","text":"<p>Self-updating OTA firmware for ESP8266</p> <p></p> <code>#uc</code> <code>#esp8266</code>","tags":["uc","esp8266"]},{"location":"notes/development-kits/esp8266/esp-01/index.html","title":"ESP-01","text":"","tags":["uc","esp8266"]},{"location":"notes/development-kits/esp8266/esp-01/index.html#pinout","title":"Pinout","text":"","tags":["uc","esp8266"]},{"location":"notes/development-kits/esp8266/esp-01/index.html#connecting-a-dht11","title":"Connecting A DHT11","text":"","tags":["uc","esp8266"]},{"location":"notes/development-kits/esp8266/esp-01/index.html#links","title":"Links","text":"<ul> <li>DHT11 Manual</li> </ul> <code>#uc</code> <code>#esp8266</code>","tags":["uc","esp8266"]},{"location":"notes/development-kits/esp8266/wemos-mini/index.html","title":"Wemos Mini","text":"","tags":["uc","esp8266"]},{"location":"notes/development-kits/esp8266/wemos-mini/index.html#flashing-micropython-on-wemos-mini","title":"Flashing MicroPython on Wemos Mini","text":"","tags":["uc","esp8266"]},{"location":"notes/development-kits/esp8266/wemos-mini/index.html#commands","title":"Commands","text":"<pre><code>pip install esptool\nesptool --port COM27 --baud 460800 write_flash --flash_size=detect -fm dio 0 esp8266-20171101-v1.9.3.bin\n\nwget https://raw.githubusercontent.com/micropython/micropython/master/drivers/sdcard/sdcard.py\npip install adafruit-ampy\nampy --port COM26 put sdcard.py\n</code></pre>","tags":["uc","esp8266"]},{"location":"notes/development-kits/esp8266/wemos-mini/index.html#notes","title":"Notes","text":"<ul> <li>Serial port uses 115200 baud</li> <li>Setup WebREPL by typing <code>import webrepl_setup</code></li> </ul>","tags":["uc","esp8266"]},{"location":"notes/development-kits/esp8266/wemos-mini/index.html#reference","title":"Reference","text":"<ul> <li>http://docs.micropython.org/en/latest/esp8266/esp8266/tutorial/intro.html#deploying-the-firmware </li> </ul> <code>#uc</code> <code>#esp8266</code>","tags":["uc","esp8266"]},{"location":"notes/development-kits/stm32/black-pill/index.html","title":"Black Pill","text":"","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/black-pill/index.html#uploading-code","title":"Uploading Code","text":"<p>There are two ways to load code onto the board:     1. Upload via JTAG     2. Upload via DFU</p>","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/black-pill/index.html#example-uploading-via-jtag","title":"Example: Uploading via JTAG","text":"<p>In this example, we'll compile the Arduino Blink example and upload it via the JTAG port using Segger Ozone.</p> <ol> <li>Compile 'Blink' sketch:     </li> <li>Upload and debug using Segger Ozone:     </li> </ol>","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/black-pill/index.html#example-uploading-via-dfu","title":"Example: Uploading via DFU","text":"","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/black-pill/index.html#example-using-micropython","title":"Example: Using MicroPython","text":"<p>To flash the Micropython firmware, do the following: - git clone https://github.com/peddamat/micropython-stm32f407ve.git - ./build.sh - ./run.sh</p> <p>The firmware files should now be in the 'output' subdirectory.</p> <p></p> <p>Power on the board in \"DFU Mode\", and then upload the 'firmware.elf' file using STM32CubeProgrammer.</p> <p></p> <p>After burning the firmware, move the Boot bin back to normal and reboot the board.</p> <p>The board should now show up as a serial port and a disk drive:</p> <p> </p> <p>Connect to the REPL via Putty and type the following:</p> <pre><code>from machine import Pin\nled = Pin(\"PA6\", Pin.OUT)\nled.low()\n</code></pre>","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/black-pill/index.html#links","title":"Links","text":"<ul> <li>STM32F407ZGT6-STM32F4XX</li> </ul> <code>#uc</code> <code>#stm32</code> <code>#arduino</code>","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/itead-maple/index.html","title":"ITead Maple","text":"","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/itead-maple/index.html#overview","title":"Overview","text":"<p>This board uses the STM32F103RBT6 chip, which is a medium-density chip.  - Tip: Pressing the 'Reset' button and immediately pressing the 'Boot' button puts the board in 'Perpetual bootloader mode', which gives you more time to upload sketches.  - Pin 0 is Serial2 RX / Pin 1 is Serial2 TX</p>","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/itead-maple/index.html#arduino-setup","title":"Arduino Setup","text":"<ol> <li>Install board support:<ul> <li>Extract 'Arduino_STM32' folder to ~/Documents/Arduino/hardware:<ul> <li>https://github.com/rogerclarkmelbourne/Arduino_STM32/archive/refs/heads/master.zip</li> </ul> </li> <li>SUPER IMPORTANT: Run 'install_drivers.bat' in drivers/win subfolder.</li> <li>Install the Arduino SAM boards (Cortex-M3) from the list of available boards.</li> <li>Reference: : https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Installation</li> </ul> </li> <li>Use \"Maple (Rev 3)\" board:     </li> </ol>","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/itead-maple/index.html#updating-bootloader","title":"Updating Bootloader","text":"<p>To use this board with Arduino, you need to do two things: 1. Install board support (see above section): 2. Install the STM32duino bootloader:     \u25cb Get the maple_rev5_boot20.bin here:         \u00a7 https://github.com/rogerclarkmelbourne/STM32duino-bootloader/tree/master/bootloader_only_binaries      \u25cb Burn using STLink or via a USB-to-Serial cable.         \u00a7 USB-to-Serial instructions: https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/stm32duino-bootloader     \u25cb NOTE: The original Maple bootloader can be found here:         \u00a7 http://docs.leaflabs.com/static.leaflabs.com/pub/leaflabs/maple-bootloader/maple_boot.bin     \u25cb After burning the bootloader, the board should be blinking slowly and should show up in 'Device Manager' under 'libusb-win32-devices' as 'Maple DFU':           \u25cb Running dfu-util -l should display the following:       3. Upload 'Blink' Sketch:     \u25cb In Arduino, open the 'Examples/01. Basics/Blink' sketch and change the LED Pins:           \u25cb Set the board configuration to 'Maple (Rev 3)'.     \u25cb Compile the sketch.     \u25cb Open a CMD window in <code>Documents\\Arduino\\hardware\\Arduino_STM32-master\\tools\\win</code> and run:         \u00a7 <code>dfu-util -a 1 -RD \"C:\\Users\\me\\AppData\\Local\\Temp\\arduino-sketch-1A9B53EE5A5605D73A1329F94E782A5F\\Blink.ino.bin\"</code>      \u25cb The sketch should upload and a new serial device should show up in \"Device Manager\":         </p> <p>Using STLink</p> <p>This board doesn't provide a SWD interface, however, section 2.3.24 of the STM32F103RBT6 datasheet mentions that the following pins are SWD pins:     \u2022 TMS -&gt; SWDIO     \u2022 TCK -&gt; SWCLK</p> <pre><code>2.3.24 Serial wire JTAG debug port (SWJ-DP)\n\nThe Arm SWJ-DP Interface is embedded. and is a combined JTAG and serial wire debug\nport that enables either a serial wire debug or a JTAG probe to be connected to the target.\nThe JTAG TMS and TCK pins are shared with SWDIO and SWCLK, respectively, and a\nspecific sequence on the TMS pin is used to switch between JTAG-DP and SW-DP.\"\n</code></pre> <p>Before burning the bootloader, do a Target -&gt; Erase Chip.</p> <p></p> <code>#uc</code> <code>#stm32</code> <code>#arduino</code>","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/super-blue-pill/index.html","title":"Super Blue Pill","text":"","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/super-blue-pill/index.html#overview","title":"Overview","text":"<p>The board uses an STM32F103C8T6 in a LQFP48 package. The front UART1 pins are Serial1 in Arduino.</p>","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/super-blue-pill/index.html#uploading-code","title":"Uploading Code","text":"<pre><code>dfu-util -a 2 -RD \"C:\\...\\AppData\\Local\\Temp\\arduino-sketch-1A9B...\\Blink.ino.bin\"\n</code></pre>","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/super-blue-pill/index.html#burning-bootloader","title":"Burning Bootloader","text":"<p>For the board to work (properly) in Arduino, you need to burn the latest STM32duino bootloader, which can be found here:     \u2022 https://github.com/rogerclarkmelbourne/STM32duino-bootloader/tree/master/binaries     \u2022 The board uses the 'generic_boot20_pa1_button_pa8.bin' binary.</p> <p>See the 'Introduction to the STM32 Blue Pill' page under 'References' for instructions on how to update the bootloader.</p> <p></p>","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/super-blue-pill/index.html#uart-pins","title":"UART Pins","text":"","tags":["uc","stm32","arduino"]},{"location":"notes/development-kits/stm32/super-blue-pill/index.html#links","title":"Links","text":"<ul> <li>Introduction to the STM32 Blue Pill (STM32duino)</li> <li>STM32F103C8T6 Black Board </li> </ul> <code>#uc</code> <code>#stm32</code> <code>#arduino</code>","tags":["uc","stm32","arduino"]},{"location":"projects/index.html","title":"Index","text":"<p>Where I make notes while I work on the things.</p>"},{"location":"projects/index.html#projects","title":"Projects","text":"<p>{{ blog_content projects }}</p>"},{"location":"projects/serialmoose-serial-port-sniffer/index.html","title":"SerialMoose Serial Port Sniffer","text":"","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#uart","title":"UART","text":"<p>A typical programming workflow is broken down into the sections provided below:</p> <ol> <li>Set Communication Parameters- Setting baud rate, data bits, stop bits, etc.</li> <li>Set Communication Pins- Assigning pins for connection to a device</li> <li>Install Drivers- Allocating ESP32\u2019s resources for the UART driver</li> <li>Run UART Communication- Sending/receiving data</li> <li>Use Interrupts- Triggering interrupts on specific communication events</li> <li>Deleting a Driver- Freeing allocated resources if a UART communication is no longer required</li> </ol> <p>Steps 1 to 3 comprise the configuration stage. Step 4 is where the UART starts operating. Steps 5 and 6 are optional.</p> <p>The UART driver\u2019s functions identify each of the UART controllers using <code>uart_port_t</code>. This identification is needed for all the following function calls. - source</p>","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#uart-async-tasks-example","title":"UART Async Tasks Example","text":"<p>This example demonstrates how two asynchronous tasks can use the same UART interface for communication. One can use this example to develop more complex applications for serial communication.</p> <p>The example starts two FreeRTOS tasks: 1. The first task periodically transmits Hello world via the UART. 2. The second task task listens, receives and prints data from the UART. - source</p>","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#code-excerpt","title":"Code Excerpt","text":"<pre><code>static void tx_task(void *arg)\n{\nstatic const char *TX_TASK_TAG = \"TX_TASK\";\nesp_log_level_set(TX_TASK_TAG, ESP_LOG_INFO);\nwhile (1) {\nsendData(TX_TASK_TAG, \"Hello world\");\nvTaskDelay(2000 / portTICK_PERIOD_MS);\n}\n}\nstatic void rx_task(void *arg)\n{\nstatic const char *RX_TASK_TAG = \"RX_TASK\";\nesp_log_level_set(RX_TASK_TAG, ESP_LOG_INFO);\nuint8_t* data = (uint8_t*) malloc(RX_BUF_SIZE+1);\nwhile (1) {\nconst int rxBytes = uart_read_bytes(UART_NUM_1, data, RX_BUF_SIZE, 1000 / portTICK_PERIOD_MS);\nif (rxBytes &gt; 0) {\ndata[rxBytes] = 0;\nESP_LOGI(RX_TASK_TAG, \"Read %d bytes: '%s'\", rxBytes, data);\nESP_LOG_BUFFER_HEXDUMP(RX_TASK_TAG, data, rxBytes, ESP_LOG_INFO);\n}\n}\nfree(data);\n}\nvoid app_main(void)\n{\ninit();\nxTaskCreate(rx_task, \"uart_rx_task\", 1024*2, NULL, configMAX_PRIORITIES, NULL);\nxTaskCreate(tx_task, \"uart_tx_task\", 1024*2, NULL, configMAX_PRIORITIES-1, NULL);\n}\n</code></pre>","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#example-output","title":"Example Output","text":"<pre><code>...\nI (3261) TX_TASK: Wrote 11 bytes\nI (4261) RX_TASK: Read 11 bytes: 'Hello world'\nI (4261) RX_TASK: 0x3ffb821c   48 65 6c 6c 6f 20 77 6f  72 6c 64                 |Hello world|\n...\n</code></pre>","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#console-output-formatting","title":"Console Output Formatting","text":"<p>ESP-IDF provides the ESP_LOG_BUFFER_HEXDUMP() routine which formats an array thusly:</p> <p><pre><code> W (195) log_example: 0x3ffb4280   45 53 50 33 32 20 69 73  20 67 72 65 61 74 2c 20  |ESP32 is great, |\n W (195) log_example: 0x3ffb4290   77 6f 72 6b 69 6e 67 20  61 6c 6f 6e 67 20 77 69  |working along wi|\n W (205) log_example: 0x3ffb42a0   74 68 20 74 68 65 20 49  44 46 2e 00              |th the IDF..|\n</code></pre> - ESP_LOG_BUFFER_HEXDUMP()</p>","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#references","title":"References","text":"<p>\u2022 UART Events Example \u2022 UART Async Tasks Example \u2022 FreeRTOS API \u2022 Event Loop Library</p>","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#baud-rate-identification","title":"Baud Rate Identification","text":"<p>Serial UART communication looks something like this:</p> <p></p> <p>A \"Start Bit\" followed by data bits, a parity, and a stop bit.  The \"baud\" rate of a channel can be determined by measuring the pulse width of the start bit and inverting it, as shown below.</p> <p></p>","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#pulse-width-measurement","title":"Pulse Width Measurement","text":"<p>Pulse width can be measured by using the \"Input Capture\" functionality found on many microcontrollers, generally part of their \"Timer\" subsystem.</p> <p>On the ST32Fx microcontrollers, a \"PWM Input\" mode exists.</p>","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#general-purpose-timers","title":"General Purpose Timers","text":"<p>The STM32Fx has four general purpose timers: TIMER2, TIMER3, TIMER4, and TIMER5.</p> <p>The block diagram for an individual timer is shown below, meaning the entire block diagram is replicated for each general purpose timer.</p> <p></p>","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#pwm-input-capture-mode","title":"PWM Input Capture Mode","text":"<p>Section \"15.3.6 PWM input mode\" of RM0008 describes a special input capture mode specifically designed for measure pulse widths of input signals.</p> <p>Adapting the documentation for Timer 2 using channel 1 and channel 2:</p> <ul> <li>TIM2_CH1 (Timer 2 channel 1) samples the external signal, generating TI1</li> <li>TIM2_CH2 (Timer 2 channel 2) is connected internally to TI1</li> </ul> <p>This mode is a particular case of input capture mode. The procedure is the same except:</p> <ul> <li>Two ICx signals (IC1 &amp; IC2) are mapped on the same Tix (TI1) input.</li> <li>These 2 ICx signals are active on edges with opposite polarity.</li> <li>One of the two TIxFP (TI1FP) signals is selected as trigger input and the slave mode controller is configured in reset mode.</li> </ul> <p>For example, the user can measure the period (in TIM2_CCR1 register) and the duty cycle (in TIM2_CCR2 register) of the PWM applied on TI1 using the following procedure (depending on CK_INT frequency and prescaler value):</p> <ul> <li>Select the active input for TIMx_CCR1 (TIM2_CCR1): write the CC1S bits to 01 in the TIMx_CCMR1 (TIM2_CCMR1)register (TI1 selected).</li> <li>Select the active polarity for TI1FP1 (used both for capture in TIMx_CCR1 (TIM2_CCR1) and counter clear): write the CC1P to \u20180\u2019 (active on rising edge) in TIM2_CCER.</li> <li>Select the active input for TIMx_CCR2 (TIM2_CCR2): write the CC2S bits to 10 in the TIMx_CCMR1 (TIM2_CCMR1) register (TI1 selected).</li> <li>Select the active polarity for TI1FP2 (used for capture in TIMx_CCR2 (TIM2_CCR2)): write the CC2P bit to \u20181\u2019 (active on falling edge).</li> <li>Select the valid trigger input: write the TS bits to 101 in the TIMx_SMCR (TIM2_SMCR) register (TI1FP1 selected).</li> <li>Configure the slave mode controller in reset mode: write the SMS bits to 100 in the TIMx_SMCR (TIM2_SMCR) register.</li> <li>Enable the captures: write the CC1E and CC2E bits to \u20181 in the TIMx_CCER (TIM2_CCER) register.</li> </ul>","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#tim2_ccmr1","title":"TIM2_CCMR1","text":"","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#tim2_ccer","title":"TIM2_CCER","text":"","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#tim2_smcr","title":"TIM2_SMCR","text":"","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#tim2_ccmr2","title":"TIM2_CCMR2","text":"","tags":["wip"]},{"location":"projects/serialmoose-serial-port-sniffer/index.html#references_1","title":"References","text":"<ol> <li>https://support.saleae.com/protocol-analyzers/analyzer-user-guides/using-async-serial</li> <li>RM0008: https://www.st.com/resource/en/reference_manual/cd00171190-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf</li> </ol> <code>#wip</code>","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html","title":"My Smart Home Devices","text":"<p>A place for me to keep notes on the devices I have integrated into Home Assistant.</p>","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#wifi-light-switches","title":"WiFi Light Switches","text":"","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#treatlife-ds01","title":"Treatlife DS01","text":"","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#treatlife-ds02-wb3s","title":"Treatlife DS02 (WB3S)","text":"<p>The switch uses the Tuya WB3S module: </p> <p>WB3S is a low-power embedded Wi-Fi+Bluetooth LE Dual protocol module that Tuya has developed. It consists of a highly integrated RF chip (BK7231T) and several peripheral components, with an embedded Wi-Fi network protocol stack and robust library functions. - source</p>","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#firmware","title":"Firmware","text":"<p>There are two projects creating replacement firmware for the module:</p> <ul> <li>LibreTuya: https://github.com/kuba2k2/libretuya<ul> <li>Documentation: https://docs.libretuya.ml/</li> </ul> </li> <li>OpenBK: https://github.com/openshwprojects/OpenBK7231T_App</li> </ul>","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#teardown","title":"Teardown","text":"","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#switches","title":"Switches","text":"","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#switchbot-mini","title":"Switchbot Mini","text":"<p>The Switchbot Mini power monitoring switches (W1901400) that I purchased are currently flashed with Tasmota.  I'd like to get them working with ESPHome.</p>","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#debugging-logs","title":"Debugging Logs","text":"Tasmota boot log <pre><code>[18:43:42]ESP-ROM:esp32c3-api1-20210207\n[18:43:42]Build:Feb  7 2021\n[18:43:42]rst:0x3 (RTC_SW_SYS_RST),boot:0xf (SPI_FAST_FLASH_BOOT)\n[18:43:42]Saved PC:0x40382e2c\n[18:43:42]SPIWP:0xee\n[18:43:42]mode:DIO, clock div:1\n[18:43:42]load:0x3fcd5810,len:0x48\n[18:43:42]load:0x403cc710,len:0x64c\n[18:43:42]load:0x403ce710,len:0x216c\n[18:43:42]SHA-256 comparison failed:\n[18:43:42]Calculated: e0d75ff7e0926df9f88222e5bdef5d235358e8deede65e96e9b562dc3b033d94\n[18:43:42]Expected: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n[18:43:42]Attempting to boot anyway...\n[18:43:42]entry 0x403cc710\n[18:43:42]\n[18:43:42]00:00:00.000 HDW: ESP32-C3 \n[18:43:42]00:00:00.004 UFS: FlashFS mounted with 308 kB free\n[18:43:42]00:00:00.012 CFG: Loaded from File, Count 7\n[18:43:42]00:00:00.017 QPC: Count 1\n[18:43:42]00:00:00.049 BRY: Berry initialized, RAM used=4521 bytes\n[18:43:42]00:00:00.058 Project tasmota - Tasmota Version 12.2.0(tasmota)-2_0_5(2022-10-17T08:39:53)\n[18:43:42]00:00:00.578 WIF: Connecting to AP1 mtconifer-iot Channel 6 BSSId 72:A7:41:10:6D:52 in mode 11n as tasmota-316744-1860...\n[18:43:45]00:00:03.044 WIF: Connected\n[18:43:45]00:00:03.300 HTP: Web server active on tasmota-316744-1860 with IP address 172.16.3.164\n[18:43:52]00:00:10.099 RSL: INFO1 = {\"Info1\":{\"Module\":\"ESP32C3\",\"Version\":\"12.2.0(tasmota)\",\"FallbackTopic\":\"cmnd/DVES_316744_fb/\",\"GroupTopic\":\"cmnd/tasmotas/\"}}\n[18:43:52]00:00:10.111 RSL: INFO2 = {\"Info2\":{\"WebServerMode\":\"Admin\",\"Hostname\":\"tasmota-316744-1860\",\"IPAddress\":\"172.16.3.164\"}}\n[18:43:52]00:00:10.123 RSL: INFO3 = {\"Info3\":{\"RestartReason\":\"Software reset digital core\",\"BootCount\":4}}\n</code></pre> Fuses <pre><code>coniferhome-esphome on \ue0a0 main [\u21d5!?] via \ud83c\udd52 base\n[I] \u279c espefuse.py -p /dev/cu.usbserial-0001 summary\nConnecting....\nDetecting chip type... ESP32-C3\nespefuse.py v3.3.1\n\n=== Run \"summary\" command ===\nEFUSE_NAME (Block) Description  = [Meaningful Value] [Readable/Writeable] (Hex Value)\n----------------------------------------------------------------------------------------\nConfig fuses:\nDIS_ICACHE (BLOCK0)                                Disables ICache                                    = False R/W (0b0)\nDIS_DOWNLOAD_ICACHE (BLOCK0)                       Disables Icache when SoC is in Download mode       = False R/W (0b0)\nDIS_FORCE_DOWNLOAD (BLOCK0)                        Disables forcing chip into Download mode           = False R/W (0b0)\nDIS_CAN (BLOCK0)                                   Disables the TWAI Controller hardware              = False R/W (0b0)\nVDD_SPI_AS_GPIO (BLOCK0)                           Set this bit to vdd spi pin function as gpio       = False R/W (0b0)\nBTLC_GPIO_ENABLE (BLOCK0)                          Enable btlc gpio                                   = 0 R/W (0b00)\nPOWERGLITCH_EN (BLOCK0)                            Set this bit to enable power glitch function       = False R/W (0b0)\nPOWER_GLITCH_DSENSE (BLOCK0)                       Sample delay configuration of power glitch         = 0 R/W (0b00)\nDIS_LEGACY_SPI_BOOT (BLOCK0)                       Disables Legacy SPI boot mode                      = False R/W (0b0)\nUART_PRINT_CHANNEL (BLOCK0)                        Selects the default UART for printing boot msg     = UART0 R/W (0b0)\nUART_PRINT_CONTROL (BLOCK0)                        Sets the default UART boot message output mode     = Enabled R/W (0b00)\nFORCE_SEND_RESUME (BLOCK0)                         Force ROM code to send a resume command during SPI = False R/W (0b0)\n                                                    bootduring SPI boot\nBLOCK_USR_DATA (BLOCK3)                            User data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\n\nEfuse fuses:\nWR_DIS (BLOCK0)                                    Disables programming of individual eFuses          = 0 R/W (0x00000000)\nRD_DIS (BLOCK0)                                    Disables software reading from BLOCK4-10           = 0 R/W (0b0000000)\n\nFlash Config fuses:\nFLASH_TPUW (BLOCK0)                                Configures flash startup delay after SoC power-up, = 0 R/W (0x0)\n                                                    unit is (ms/2). When the value is 15, delay is 7.\n                                                   5 ms\n\nIdentity fuses:\nSECURE_VERSION (BLOCK0)                            Secure version (used by ESP-IDF anti-rollback feat = 0 R/W (0x0000)\n                                                   ure)\nMAC (BLOCK1)                                       Factory MAC Address\n   = a0:76:4e:31:67:44 (OK) R/W\nWAFER_VERSION (BLOCK1)                             WAFER version                                      = 3 R/W (0b011)\nPKG_VERSION (BLOCK1)                               Package version                                    = ESP32-C3 R/W (0b000)\nBLOCK1_VERSION (BLOCK1)                            BLOCK1 efuse version                               = 4 R/W (0b100)\nOPTIONAL_UNIQUE_ID (BLOCK2)                        Optional unique 128-bit ID\n   = e5 0b 40 a2 c7 ed 29 50 6d 9e 1a 5f d2 a4 bd 9f R/W\nBLOCK2_VERSION (BLOCK2)                            Version of BLOCK2                                  = 5 R/W (0b101)\nCUSTOM_MAC (BLOCK3)                                Custom MAC Address\n   = 00:00:00:00:00:00 (OK) R/W\n\nJtag Config fuses:\nSOFT_DIS_JTAG (BLOCK0)                             Software disables JTAG. When software disabled, JT = 0 R/W (0b000)\n                                                   AG can be activated temporarily by HMAC peripheral\nDIS_PAD_JTAG (BLOCK0)                              Permanently disable JTAG access via pads. USB JTAG = False R/W (0b0)\n                                                    is controlled separately.\n\nSecurity fuses:\nDIS_DOWNLOAD_MANUAL_ENCRYPT (BLOCK0)               Disables flash encryption when in download boot mo = False R/W (0b0)\n                                                   des\nSPI_BOOT_CRYPT_CNT (BLOCK0)                        Enables encryption and decryption, when an SPI boo = Disable R/W (0b000)\n                                                   t mode is set. Enabled when 1 or 3 bits are set,di\n                                                   sabled otherwise\nSECURE_BOOT_KEY_REVOKE0 (BLOCK0)                   If set, revokes use of secure boot key digest 0    = False R/W (0b0)\nSECURE_BOOT_KEY_REVOKE1 (BLOCK0)                   If set, revokes use of secure boot key digest 1    = False R/W (0b0)\nSECURE_BOOT_KEY_REVOKE2 (BLOCK0)                   If set, revokes use of secure boot key digest 2    = False R/W (0b0)\nKEY_PURPOSE_0 (BLOCK0)                             KEY0 purpose                                       = USER R/W (0x0)\nKEY_PURPOSE_1 (BLOCK0)                             KEY1 purpose                                       = USER R/W (0x0)\nKEY_PURPOSE_2 (BLOCK0)                             KEY2 purpose                                       = USER R/W (0x0)\nKEY_PURPOSE_3 (BLOCK0)                             KEY3 purpose                                       = USER R/W (0x0)\nKEY_PURPOSE_4 (BLOCK0)                             KEY4 purpose                                       = USER R/W (0x0)\nKEY_PURPOSE_5 (BLOCK0)                             KEY5 purpose                                       = USER R/W (0x0)\nSECURE_BOOT_EN (BLOCK0)                            Enables secure boot                                = False R/W (0b0)\nSECURE_BOOT_AGGRESSIVE_REVOKE (BLOCK0)             Enables aggressive secure boot key revocation mode = False R/W (0b0)\nDIS_DOWNLOAD_MODE (BLOCK0)                         Disables all Download boot modes                   = False R/W (0b0)\nENABLE_SECURITY_DOWNLOAD (BLOCK0)                  Enables secure UART download mode (read/write flas = False R/W (0b0)\n                                                   h only)\nBLOCK_KEY0 (BLOCK4)\n  Purpose: USER\n               Encryption key0 or user data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\nBLOCK_KEY1 (BLOCK5)\n  Purpose: USER\n               Encryption key1 or user data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\nBLOCK_KEY2 (BLOCK6)\n  Purpose: USER\n               Encryption key2 or user data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\nBLOCK_KEY3 (BLOCK7)\n  Purpose: USER\n               Encryption key3 or user data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\nBLOCK_KEY4 (BLOCK8)\n  Purpose: USER\n               Encryption key4 or user data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\nBLOCK_KEY5 (BLOCK9)\n  Purpose: USER\n               Encryption key5 or user data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\nBLOCK_SYS_DATA2 (BLOCK10)                          System data (part 2)\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\n\nSpi_Pad_Config fuses:\nSPI_PAD_CONFIG_CLK (BLOCK1)                        SPI CLK pad                                        = 0 R/W (0b000000)\nSPI_PAD_CONFIG_Q (BLOCK1)                          SPI Q (D1) pad                                     = 0 R/W (0b000000)\nSPI_PAD_CONFIG_D (BLOCK1)                          SPI D (D0) pad                                     = 0 R/W (0b000000)\nSPI_PAD_CONFIG_CS (BLOCK1)                         SPI CS pad                                         = 0 R/W (0b000000)\nSPI_PAD_CONFIG_HD (BLOCK1)                         SPI HD (D3) pad                                    = 0 R/W (0b000000)\nSPI_PAD_CONFIG_WP (BLOCK1)                         SPI WP (D2) pad                                    = 0 R/W (0b000000)\nSPI_PAD_CONFIG_DQS (BLOCK1)                        SPI DQS pad                                        = 0 R/W (0b000000)\nSPI_PAD_CONFIG_D4 (BLOCK1)                         SPI D4 pad                                         = 0 R/W (0b000000)\nSPI_PAD_CONFIG_D5 (BLOCK1)                         SPI D5 pad                                         = 0 R/W (0b000000)\nSPI_PAD_CONFIG_D6 (BLOCK1)                         SPI D6 pad                                         = 0 R/W (0b000000)\nSPI_PAD_CONFIG_D7 (BLOCK1)                         SPI D7 pad                                         = 0 R/W (0b000000)\n\nUsb Config fuses:\nDIS_USB_JTAG (BLOCK0)                              Disables USB JTAG. JTAG access via pads is control = False R/W (0b0)\n                                                   led separately\nDIS_USB_DEVICE (BLOCK0)                            Disables USB DEVICE                                = False R/W (0b0)\nUSB_EXCHG_PINS (BLOCK0)                            Exchanges USB D+ and D- pins                       = False R/W (0b0)\nDIS_USB_DOWNLOAD_MODE (BLOCK0)                     Disables use of USB in UART download boot mode     = False R/W (0b0)\n\nWdt Config fuses:\nWDT_DELAY_SEL (BLOCK0)                             Selects RTC WDT timeout threshold at startup       = False R/W (0b0)\n</code></pre> ESPHome Boot Log <p>``` [I] \u279c esptool.py --chip esp32c3 --baud 921600 --before default_reset --after hard_reset write_flash -z --flash_mode dout --flash_size detect 0x0 build/kitchen-fridge-outlet/.pioenvs/kitchen-fridge-outlet/firmware.bin esptool.py v3.3.1 Found 3 serial ports Serial port /dev/cu.usbserial-0001 Connecting... Chip is ESP32-C3 (revision 3) Features: Wi-Fi Crystal is 40MHz MAC: a0:76:4e:31:67:44 Uploading stub... Running stub... Stub running... Changing baud rate to 921600 Changed. Configuring flash size... Auto-detected Flash size: 4MB Flash will be erased from 0x00000000 to 0x000c0fff... Flash params set to 0x032f Compressed 786832 bytes to 463199... Wrote 786832 bytes (463199 compressed) at 0x00000000 in 12.1 seconds (effective 519.8 kbit/s)... Hash of data verified.</p> <pre><code>Leaving...\nHard resetting via RTS pin...\n[10:27:01]ESP-ROM:esp32c3-api1-20210207\n[10:27:01]Build:Feb  7 2021\n[10:27:01]rst:0x10 (RTCWDT_RTC_RST),boot:0xf (SPI_FAST_FLASH_BOOT)\n[10:27:01]SPIWP:0xee\n[10:27:01]mode:DOUT, clock div:1\n[10:27:01]load:0x3c0a0020,len:0x1da70\n[10:27:01]load:0x3fc8de00,len:0x2580\n[10:27:01]load:0x42000020,len:0x91668\n[10:27:01]load:0x3fc90380,len:0xd10\n[10:27:01]load:0x40380000,len:0xdda8\n[10:27:01]load:0x50000000,len:0x10\n[10:27:01]SHA-256 comparison failed:\n[10:27:02]Calculated: e159e39a79c819ff4e2d3877a9127907c0315d0dd5156f4b9d846052ca549fa6\n[10:27:02]Expected: 16e0a551ee1cfc3ca0f4f55c7bc36a7289273a42a43c798cd454f972eed7f0da\n[10:27:02]Attempting to boot anyway...\n[10:27:02]entry 0x40380ae6\n```\n</code></pre> Fuses <pre><code>[I] \u279c espefuse.py -p /dev/cu.usbserial-0001 summary\nConnecting....\nDetecting chip type... ESP32-C3\nespefuse.py v3.3.1\n\n=== Run \"summary\" command ===\nEFUSE_NAME (Block) Description  = [Meaningful Value] [Readable/Writeable] (Hex Value)\n----------------------------------------------------------------------------------------\nConfig fuses:\nDIS_ICACHE (BLOCK0)                                Disables ICache                                    = False R/W (0b0)\nDIS_DOWNLOAD_ICACHE (BLOCK0)                       Disables Icache when SoC is in Download mode       = False R/W (0b0)\nDIS_FORCE_DOWNLOAD (BLOCK0)                        Disables forcing chip into Download mode           = False R/W (0b0)\nDIS_CAN (BLOCK0)                                   Disables the TWAI Controller hardware              = False R/W (0b0)\nVDD_SPI_AS_GPIO (BLOCK0)                           Set this bit to vdd spi pin function as gpio       = False R/W (0b0)\nBTLC_GPIO_ENABLE (BLOCK0)                          Enable btlc gpio                                   = 0 R/W (0b00)\nPOWERGLITCH_EN (BLOCK0)                            Set this bit to enable power glitch function       = False R/W (0b0)\nPOWER_GLITCH_DSENSE (BLOCK0)                       Sample delay configuration of power glitch         = 0 R/W (0b00)\nDIS_LEGACY_SPI_BOOT (BLOCK0)                       Disables Legacy SPI boot mode                      = False R/W (0b0)\nUART_PRINT_CHANNEL (BLOCK0)                        Selects the default UART for printing boot msg     = UART0 R/W (0b0)\nUART_PRINT_CONTROL (BLOCK0)                        Sets the default UART boot message output mode     = Enabled R/W (0b00)\nFORCE_SEND_RESUME (BLOCK0)                         Force ROM code to send a resume command during SPI = False R/W (0b0)\n                                                    bootduring SPI boot\nBLOCK_USR_DATA (BLOCK3)                            User data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\n\nEfuse fuses:\nWR_DIS (BLOCK0)                                    Disables programming of individual eFuses          = 0 R/W (0x00000000)\nRD_DIS (BLOCK0)                                    Disables software reading from BLOCK4-10           = 0 R/W (0b0000000)\n\nFlash Config fuses:\nFLASH_TPUW (BLOCK0)                                Configures flash startup delay after SoC power-up, = 0 R/W (0x0)\n                                                    unit is (ms/2). When the value is 15, delay is 7.\n                                                   5 ms\n\nIdentity fuses:\nSECURE_VERSION (BLOCK0)                            Secure version (used by ESP-IDF anti-rollback feat = 0 R/W (0x0000)\n                                                   ure)\nMAC (BLOCK1)                                       Factory MAC Address\n   = a0:76:4e:31:67:44 (OK) R/W\nWAFER_VERSION (BLOCK1)                             WAFER version                                      = 3 R/W (0b011)\nPKG_VERSION (BLOCK1)                               Package version                                    = ESP32-C3 R/W (0b000)\nBLOCK1_VERSION (BLOCK1)                            BLOCK1 efuse version                               = 4 R/W (0b100)\nOPTIONAL_UNIQUE_ID (BLOCK2)                        Optional unique 128-bit ID\n   = e5 0b 40 a2 c7 ed 29 50 6d 9e 1a 5f d2 a4 bd 9f R/W\nBLOCK2_VERSION (BLOCK2)                            Version of BLOCK2                                  = 5 R/W (0b101)\nCUSTOM_MAC (BLOCK3)                                Custom MAC Address\n   = 00:00:00:00:00:00 (OK) R/W\n\nJtag Config fuses:\nSOFT_DIS_JTAG (BLOCK0)                             Software disables JTAG. When software disabled, JT = 0 R/W (0b000)\n                                                   AG can be activated temporarily by HMAC peripheral\nDIS_PAD_JTAG (BLOCK0)                              Permanently disable JTAG access via pads. USB JTAG = False R/W (0b0)\n                                                    is controlled separately.\n\nSecurity fuses:\nDIS_DOWNLOAD_MANUAL_ENCRYPT (BLOCK0)               Disables flash encryption when in download boot mo = False R/W (0b0)\n                                                   des\nSPI_BOOT_CRYPT_CNT (BLOCK0)                        Enables encryption and decryption, when an SPI boo = Disable R/W (0b000)\n                                                   t mode is set. Enabled when 1 or 3 bits are set,di\n                                                   sabled otherwise\nSECURE_BOOT_KEY_REVOKE0 (BLOCK0)                   If set, revokes use of secure boot key digest 0    = False R/W (0b0)\nSECURE_BOOT_KEY_REVOKE1 (BLOCK0)                   If set, revokes use of secure boot key digest 1    = False R/W (0b0)\nSECURE_BOOT_KEY_REVOKE2 (BLOCK0)                   If set, revokes use of secure boot key digest 2    = False R/W (0b0)\nKEY_PURPOSE_0 (BLOCK0)                             KEY0 purpose                                       = USER R/W (0x0)\nKEY_PURPOSE_1 (BLOCK0)                             KEY1 purpose                                       = USER R/W (0x0)\nKEY_PURPOSE_2 (BLOCK0)                             KEY2 purpose                                       = USER R/W (0x0)\nKEY_PURPOSE_3 (BLOCK0)                             KEY3 purpose                                       = USER R/W (0x0)\nKEY_PURPOSE_4 (BLOCK0)                             KEY4 purpose                                       = USER R/W (0x0)\nKEY_PURPOSE_5 (BLOCK0)                             KEY5 purpose                                       = USER R/W (0x0)\nSECURE_BOOT_EN (BLOCK0)                            Enables secure boot                                = False R/W (0b0)\nSECURE_BOOT_AGGRESSIVE_REVOKE (BLOCK0)             Enables aggressive secure boot key revocation mode = False R/W (0b0)\nDIS_DOWNLOAD_MODE (BLOCK0)                         Disables all Download boot modes                   = False R/W (0b0)\nENABLE_SECURITY_DOWNLOAD (BLOCK0)                  Enables secure UART download mode (read/write flas = False R/W (0b0)\n                                                   h only)\nBLOCK_KEY0 (BLOCK4)\n  Purpose: USER\n               Encryption key0 or user data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\nBLOCK_KEY1 (BLOCK5)\n  Purpose: USER\n               Encryption key1 or user data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\nBLOCK_KEY2 (BLOCK6)\n  Purpose: USER\n               Encryption key2 or user data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\nBLOCK_KEY3 (BLOCK7)\n  Purpose: USER\n               Encryption key3 or user data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\nBLOCK_KEY4 (BLOCK8)\n  Purpose: USER\n               Encryption key4 or user data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\nBLOCK_KEY5 (BLOCK9)\n  Purpose: USER\n               Encryption key5 or user data\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\nBLOCK_SYS_DATA2 (BLOCK10)                          System data (part 2)\n   = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W\n\nSpi_Pad_Config fuses:\nSPI_PAD_CONFIG_CLK (BLOCK1)                        SPI CLK pad                                        = 0 R/W (0b000000)\nSPI_PAD_CONFIG_Q (BLOCK1)                          SPI Q (D1) pad                                     = 0 R/W (0b000000)\nSPI_PAD_CONFIG_D (BLOCK1)                          SPI D (D0) pad                                     = 0 R/W (0b000000)\nSPI_PAD_CONFIG_CS (BLOCK1)                         SPI CS pad                                         = 0 R/W (0b000000)\nSPI_PAD_CONFIG_HD (BLOCK1)                         SPI HD (D3) pad                                    = 0 R/W (0b000000)\nSPI_PAD_CONFIG_WP (BLOCK1)                         SPI WP (D2) pad                                    = 0 R/W (0b000000)\nSPI_PAD_CONFIG_DQS (BLOCK1)                        SPI DQS pad                                        = 0 R/W (0b000000)\nSPI_PAD_CONFIG_D4 (BLOCK1)                         SPI D4 pad                                         = 0 R/W (0b000000)\nSPI_PAD_CONFIG_D5 (BLOCK1)                         SPI D5 pad                                         = 0 R/W (0b000000)\nSPI_PAD_CONFIG_D6 (BLOCK1)                         SPI D6 pad                                         = 0 R/W (0b000000)\nSPI_PAD_CONFIG_D7 (BLOCK1)                         SPI D7 pad                                         = 0 R/W (0b000000)\n\nUsb Config fuses:\nDIS_USB_JTAG (BLOCK0)                              Disables USB JTAG. JTAG access via pads is control = False R/W (0b0)\n                                                   led separately\nDIS_USB_DEVICE (BLOCK0)                            Disables USB DEVICE                                = False R/W (0b0)\nUSB_EXCHG_PINS (BLOCK0)                            Exchanges USB D+ and D- pins                       = False R/W (0b0)\nDIS_USB_DOWNLOAD_MODE (BLOCK0)                     Disables use of USB in UART download boot mode     = False R/W (0b0)\n\nWdt Config fuses:\nWDT_DELAY_SEL (BLOCK0)                             Selects RTC WDT timeout threshold at startup       = False R/W (0b0)\n</code></pre>","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#reference","title":"Reference","text":"<ul> <li>https://github.com/kendallgoto/switchbota</li> <li>https://community.home-assistant.io/t/support-for-switchbot-plug-mini-w1901400-with-bluetooth-proxying/441893</li> </ul>","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#localtuya","title":"localtuya","text":"<ul> <li>Support updating MCU firmware</li> <li>Support setting dimmer lower range to 1%</li> </ul>","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#pykasa","title":"pykasa","text":"<ul> <li>Support PIR and LAS modules</li> </ul>","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#serial-dump","title":"Serial dump","text":"","tags":["wip"]},{"location":"projects/home-assistant/my-smart-home-devices/index.html#ceiling-fan-switch","title":"Ceiling Fan Switch","text":"<ul> <li>https://developer.tuya.com/en/docs/iot/tuya-cloud-universal-serial-port-access-protocol?id=K9hhi0xxtn9cb#title-12-Send%20commands</li> </ul> <p><pre><code>Field   Bytes   Description\nHeader  2   0x55aa\nVersion 1   0x00\nCommand 1   0x06\nData length 2   Depends on the type and number of data units.\nData    N   Data units\nChecksum    1   Start from the header, add up all the bytes, and then divide the sum by 256 to get the remainder.\n\n55aa 00 06 0008 69 02 00 04 00 00 00 5a d6\n55aa 00 06 0008 69 02 00 04 00 00 00 5d d9\n55aa 00 00 0000 ff\n55aa 00 06 0008 69 02 00 04 00 00 00 34 b0\n55aa 00 06 0008 69 02 00 04 00 00 00 2b a7\n55aa 00 06 0008 69 02 00 04 00 00 00 22 9e\n55aa 00 06 0008 69 02 00 04 00 00 00 16 92\n55aa 00 06 0008 69 02 00 04 00 00 00 0b 87\n55aa 00 06 0008 69 02 00 04 00 00 00 0a 86\n55aa 00 06 0008 69 02 00 04 00 00 00 0a 86\n55aa 00 06 0005 6a 04 00 01 01 7a\n\ndpid: 69\ntype: Value (4-bytes)\nlen: 4 bytes\nvalue: 0x0a (10) \n\n55AA 03 07 0008 02 02 00 04 00 00 00 0A 23\n\n# https://templates.blakadder.com/treatlife_DS02S.html\n# Dimming mode 1\n55AA 00 06 0005 04 04 00 01 00 13\n</code></pre> </p> <code>#wip</code>","tags":["wip"]},{"location":"projects/home-assistant/samsung-refrigerator-integration/index.html","title":"Samsung Refrigerator Integration","text":"","tags":["wip"]},{"location":"projects/home-assistant/samsung-refrigerator-integration/index.html#overview","title":"Overview","text":"<p>My fridge is an:  RF23M8070SR</p> <p></p> <p></p>","tags":["wip"]},{"location":"projects/home-assistant/samsung-refrigerator-integration/index.html#samsung-wifi-dongle","title":"Samsung WiFi Dongle","text":"<p>I purchased the Samsung Smart Home Adapter (HD39J1230GW) to integrate the kitchen fridge (Samsung  RF23M8070SR) with Home Assistant.  The dongle works poorly so I'd like to figure out how it works to see if I can improve it's functionality.  There are no datasheets available, so comparing the images below, it appears that the \"USB\" connector is actually carrying a UART serial port signal.</p> <p>This makes sense since the cabling to the port on the fridge is not shielded and due to the level shifting FETs on the top-left of the board.</p> <p>The dongle uses the Qualcomm QCA4531 SoC: - https://www.qualcomm.com/products/technology/wi-fi/qca4531#Overview</p>","tags":["wip"]},{"location":"projects/home-assistant/samsung-refrigerator-integration/index.html#teardown","title":"Teardown","text":"","tags":["wip"]},{"location":"projects/home-assistant/samsung-refrigerator-integration/index.html#usb-pinout","title":"USB Pinout","text":"","tags":["wip"]},{"location":"projects/home-assistant/samsung-refrigerator-integration/index.html#qualcomm-qca4531-soc","title":"Qualcomm QCA4531 SoC","text":"","tags":["wip"]},{"location":"projects/home-assistant/samsung-refrigerator-integration/index.html#references","title":"References","text":"<ul> <li>https://github.com/zigpy/zigpy/discussions/796</li> <li>https://usermanual.wiki/Samsung-Electronics-Co/SWL-CQ51/html</li> </ul>","tags":["wip"]},{"location":"projects/home-assistant/samsung-refrigerator-integration/index.html#refrigerator-system-board","title":"Refrigerator System Board","text":"<code>#wip</code>","tags":["wip"]},{"location":"projects/hunter-hacking/learning-how-to-mitm-an-atwinc1500/index.html","title":"Learning How To MitM An ATWINC1500","text":"<p>In How To Quickly Setup A Wireless MitM Proxy, I discussed how to setup a \"Man In The Middle\" (MitM) proxy using Kali Linux, but what is  a man-in-the-middle proxy?  What are they used for?</p> <p>In this article we'll explore MitM proxies using Kali Linux and an Adafruit Feather M0 WiFi module.</p>","tags":["microchip","firmware","analysis","uC","mitm"]},{"location":"projects/hunter-hacking/learning-how-to-mitm-an-atwinc1500/index.html#the-basics","title":"The Basics","text":"<p>A man-in-the-middle (MITM) proxy is an application or device that intercepts communication between two parties and can eavesdrop, modify or block data transmission.</p> <p></p> <p>In the early days of the internet, before the Let's Encrypt  revolution, it was ridiculously easy to insert yourself in between one computer and another.  (insert cain-and-abel, etc...)</p> <p>Nowadays, it's basically impossible to \"sniff\" a random TLS-secured connection, but if you have control of one of the devices, things become much easier.</p> <p>To better understand things, let's setup a simple testbed.</p>","tags":["microchip","firmware","analysis","uC","mitm"]},{"location":"projects/hunter-hacking/learning-how-to-mitm-an-atwinc1500/index.html#1-mitm-a-simple-ssl-connection","title":"1. MitM A Simple SSL Connection","text":"<p>WiFiSSLClient.ino </p> <code>#microchip</code> <code>#firmware</code> <code>#analysis</code> <code>#uC</code> <code>#mitm</code>","tags":["microchip","firmware","analysis","uC","mitm"]},{"location":"projects/hunter-hacking/mitm-a-hunter-pro-hc/index.html","title":"MitM A Hunter Pro HC","text":"","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/mitm-a-hunter-pro-hc/index.html#firmware-extraction","title":"Firmware Extraction","text":"<p>Hunter Pro-HC Firmware Dump</p> Hunter Pro-HC<pre><code>$ winc_programmer_uart.exe -p COM4 -d winc1500 -r -pfw programmer_firmware.bin -o atwinc1500-hunter.bin\nWINC Programming Tool 2.0.1 [ceebe5f] (Apr 20 2022)\nCopyright (C) Microchip Technology Inc. 2022\nhardware WINC serial bridge found\nchip ID is 0x001503a0\nprogramming firmware file: programmer_firmware.bin\nreinitialise onchip uart to 500000\nwaiting for firmware to run\nflash ID 0xc21320c2\nflash size is 4 Mb\n\nbegin read operation\n\n0x000000:[rrrrrrrr] 0x008000:[rrrrrrrr] 0x010000:[rrrrrrrr] 0x018000:[rrrrrrrr]\n0x020000:[rrrrrrrr] 0x028000:[rrrrrrrr] 0x030000:[rrrrrrrr] 0x038000:[rrrrrrrr]\n0x040000:[rrrrrrrr] 0x048000:[rrrrrrrr] 0x050000:[rrrrrrrr] 0x058000:[rrrrrrrr]\n0x060000:[rrrrrrrr] 0x068000:[rrrrrrrr] 0x070000:[rrrrrrrr] 0x078000:[rrrrrrrr]\noutput file format not specified, assuming 'raw'\n</code></pre> <p></p> <code>#microchip</code> <code>#firmware</code> <code>#analysis</code> <code>#uC</code>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html","title":"Taking Apart A Hunter Pro HC Controller","text":"<p>I recently completed a redesign of my home's irrigation system, replacing an old Rainbird ESP-2 controller with a Hunter Pro-HC, a  \"professional-grade WiFi controller for residential and light commercial applications\".</p> <p></p> <p>The controller is part of the \"Hydrawise\" family of devices, a platform to enable internet-connectivity.</p> <p>The platform is great, but does not provide any mechanisms for local control of the controller.</p>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#research","title":"Research","text":"<p>While adding the controller to my network, I came across this blurb here:</p> <p></p> <p>Which seems to indicate that it uses Secure MQTT to communicate with its backend services.</p> <p>If Hydrawise is, in fact, built using MQTT, it would be fantastic, because MQTT and Home Assistant go together like ice cream and apple pie.</p> <p>Sniffing the controller's traffic confirms port 8883 traffic to backend services hosted on AWS:</p> <p></p>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#objectives","title":"Objectives","text":"<p>At this point, I figure there are basically two paths forward:</p> <ul> <li>Exploit the device and replace firmware ala ESPHome</li> <li>Extract TLS keys and MitM backend traffic</li> </ul> <p>Let\u2019s continue our investigation and see which option makes the most sense.</p>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#internals","title":"Internals","text":"","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#pcb","title":"PCB","text":"<p>Cracking open the device reveals a nicely designed PCB:</p> <p> </p> <p>The two interesting ICs on the PCB are a Microchip PIC32 microcontroller and an Atmel ATWINC1500 WiFi module:</p> <p></p>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#microchip-pic32","title":"Microchip PIC32","text":"<p>The Microchip PIC32MX370F512L is a 32-bit MIPS-based microcontroller with the following specs:</p> <p></p> <p>With specs like that, we can assume that this puppy is the \"brains\" behind the Hunter controller, and contains the code which communicates with the Hydrawise backend systems.</p> <p></p>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#documentation","title":"Documentation","text":"<ul> <li>Datasheet</li> <li>Pinout </li> </ul>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#atmel-atwinc1500","title":"Atmel ATWINC1500","text":"<p>The Atmel ATWINC1500-MR210PB is an 802.11 b/g/n \"IoT Module\", which seems like a fancy way of saying \"WiFi module\". </p>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#pinout","title":"Pinout","text":"<p>Page 7 of the datasheet contains a pin-out diagram which indicates that the module has the following interfaces: UART, SPI, and I2C.</p> <p></p>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#documentation_1","title":"Documentation","text":"<ul> <li>Datasheet</li> <li>Wi-Fi Network Controller Software Design Guide</li> <li>Wi-Fi Network Controller Software Programming Guide</li> <li>Integrated Serial Flash and Memory Download Procedure</li> <li>Transport Layer Security (TLS) User's Guide</li> </ul>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#tracing","title":"Tracing","text":"<p>The board has a number of headers, so it seems logical to see what pins are broken out.</p>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#how-to-trace","title":"How To Trace","text":"<p>The best technique I\u2019ve found for tracing double-layered boards is to photograph both sides, then line them up carefully in an image editor.</p> <p>Adjusting opacities and/or toggling layers while carefully tracing with a cursor yields the best results:</p> <p></p>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#board-outs","title":"Board Outs","text":"<p>Here\u2019s what I discovered:</p> <p></p>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#taking-stock","title":"Taking Stock","text":"<p>From our initial explorations, it does seem possible for us to continue our journey with either the PIC32 or the Atmel WiFI device.</p> <p>However, revisiting our objective, being able to integrate the device into Home Assistant.</p> <p>Let's start with Atmel device.</p>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#firmware-analysis","title":"Firmware Analysis","text":"","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#firmware-patching","title":"Firmware Patching","text":"","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#links","title":"Links","text":"<ul> <li>WINC1500 Firmware Update Methods</li> </ul>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#example-code","title":"Example Code","text":"<ul> <li>MPLAB-Harmony Serial Bridge Project</li> <li>Arduino Wifi101 Firmware Updater - writing the certs to offset 0x00004000</li> <li>Debug UART Firmware Upgrade Example </li> <li>Code for updating certificate stores</li> </ul>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/taking-apart-a-hunter-pro-hc-controller/index.html#tool-links","title":"Tool Links","text":"<ul> <li>MPLAB-Harmony winc_programmer_uart.exe</li> <li>pitaya-go tls_cert_flash_tool.exe</li> </ul> <code>#hunter</code> <code>#sprinker</code> <code>#irrigation</code> <code>#uC</code> <code>#teardown</code>","tags":["hunter","sprinker","irrigation","uC","teardown"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html","title":"Understanding The ATWINC1500 Module","text":"<p>The Microchip ATWINC1500 IoT Module is a low-cost 802.11 b/g/n WiFi module, popular in the \"maker\" DIY electronics communities, </p> <ul> <li>Adafruit Feather M0 WiFi </li> <li>Arduino WiFi Shield</li> <li>Arduino WiFi101 Library</li> </ul> <p>Support for the module is even baked into Arduino: Pasted image 20230313235600.png|Arduino WiFI101 Firmware/Certificates Updater</p> <p>As part of the Taking Apart A Hunter Pro-HC Controller Project, I did a deep-dive into the module to...</p>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#10000ft-view","title":"10000ft View","text":"","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#architecture","title":"Architecture","text":"<p>The module has an embedded Cortus APS3 32-bit RISC processor with an internal 2Mb or 4Mb SPI flash.  During startup and mode changes firmware is loaded from the serial flash into program memory (IRAM) in which firmware is executed.</p>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#memory-layout","title":"Memory Layout","text":"<p>The internal flash has the following layout:</p> <p> - source</p> <p>Why is there two location to store certificates in ATWINC15x0 flash? What is the difference between Root Certificate and TLS Certificate/key storage in ATWINC15x0 flash memory?</p> <p>There are two specific locations to store different certificates into WINC flash memory:</p> <ol> <li>X.509 Root Certificate storage - This is for the ATWINC1500 TLS Client to verify the TLS server certificate (A self signed public key certificate that identify the authority) from the server that the module is trying to connect. (eg. When ATWINC1500 is trying to connect to google.com, device will use the \"GlobalSign Root CA\" certificate stored in the Root Certificate folder to verify the server certificate)   - Size of memory assigned for this is 4KB.   - Refer to ATWINC15x0/ATWINC3400 Integrated Serial Flash and Memory Download Procedure -  http://ww1.microchip.com/downloads/en/DeviceDoc/00002378B.pdf#page=21: \"The WINC saves the TLS/SSL certificates inside the serial Flash in 4K sector (the maximum size of all certificates in Flash must be less than 4K).\"</li> <li>ATWINC1500 TLS Server certificate storage - For proper operation of both the TLS server and TLS client authentication, the ATWINC1500 device must have a certificate/private key pair assigned to it.   - An 8KB flash area is reserved for storing the TLS certificates.   - Refer to TLS userguide: http://ww1.microchip.com/downloads/en/DeviceDoc/50002599A.pdf#page=3: \"An 8KB flash area is reserved for storing the TLS certificates starting from offset 20KB in the ATWINC1500 stacked flash.\"</li> </ol> <p>Note: The certificate storage size is not dependent on the firmware or flash variant, it will remain the same across.</p>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#root-certificate-store","title":"Root Certificate Store","text":"<p>Section 7 \"Transport Layer Security (TLS)\" of the Wi-Fi Network Controller Software Design Guide explains that:</p> <p>Before connecting to a TLS Server, the root certificat of the server must be installed on the ATWINC15x0...</p> <p></p> <p>Section 6 of the Integrated Serial Flash and Memory Download Procedure describes the procedure for installing certificates:</p> <p></p>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#tls-server-store","title":"TLS Server Store","text":"<p>Section 2 of the Transport Layer Security (TLS) User's Guide describes the procedure for installing certificates:</p> <p> </p>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#links","title":"Links","text":"<ul> <li>spi_flash_map.h</li> </ul>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#interfaces","title":"Interfaces","text":"<p>Page 7 of the datasheet contains a pin-out diagram which indicates that the module has the following interfaces: UART, SPI, and I2C.</p> <p></p>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#debug-interfaces","title":"Debug Interfaces","text":"<p>Page 20 of the datasheet indicates that the UART and I2C interfaces are for \"debugging purposes\" only:</p> <p></p> <p>The __ explains that for the debug interfaces to be enabled, the module must be powered on with a specific sequence:</p> <p></p>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#debug-uart","title":"Debug UART","text":"<p>Section 3 of the Integrated Serial Flash and Memory Download Procedure describes...</p> <p></p>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#firmware-extraction","title":"Firmware Extraction","text":"<p>The WINC1500 : Using Image Tool to build firmware image, gain table and program using serial bridge mentions that the module's firmware can be extracted by connecting a 3.3v TTL USB-to-Serial cable to pins UART_TXD and UART_RXD of module and executing the following command:</p> <pre><code>winc_programmer_uart.exe -p COM4 -d winc1500 -r -pfw ..\\programmer_firmware\\release3A0\\programmer_firmware.bin -o atwinc1500-original.bin\n</code></pre> <p>Let's give it a shot!</p>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#wiring","title":"Wiring","text":"<p>I will be using the above method to extract firmware from an Adafruit Feather M0 WiFi development module.</p> <p>I'll be using a CP... USB-TTL module:</p> <p></p> <p>Since I don't have a fancy POGO rig, I made a simple jig to hold the leads in place while the firmware is extracting:</p> <p> </p>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#debug-sequence","title":"Debug Sequence","text":"<p>As mentioned in Understanding The ATWINC1500 ModuleDebug Interfaces, to enable the debug interfaces, the ATWINC1500 module needs a specific boot-up sequence.</p> <p>Since the Adafruit is Arduino, I wrote a simple sketch:</p> <pre><code>#define CE_PIN 2\n#define RST_PIN 4\nvoid setup() {\npinMode(LED_BUILTIN, OUTPUT);\npinMode(CE_PIN, OUTPUT);\npinMode(RST_PIN, OUTPUT);\ndigitalWrite(CE_PIN, LOW);\ndigitalWrite(RST_PIN, LOW);\ndelay(1000);\ndigitalWrite(CE_PIN, HIGH);\ndelay(100);\ndigitalWrite(RST_PIN, HIGH);\n}\nvoid loop() {\ndigitalWrite(LED_BUILTIN, HIGH);  // turn the LED on (HIGH is the voltage level)\ndelay(1000);                      // wait for a second\ndigitalWrite(LED_BUILTIN, LOW);   // turn the LED off by making the voltage LOW\ndelay(1000);   }\n</code></pre> <p>Note to my future self, don't forget to set the Port!  </p> <p></p>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#dumping-the-firmware","title":"Dumping The Firmware","text":"<p>Adafruit Feather M0 Firmware Dump</p> Adafruit Feather M0<pre><code>$ winc_programmer_uart.exe -p COM4 -d winc1500 -r -pfw programmer_firmware.bin -o atwinc1500-original.bin\nWINC Programming Tool 2.0.1 [ceebe5f] (Apr 20 2022)\nCopyright (C) Microchip Technology Inc. 2022\nhardware WINC serial bridge found\nchip ID is 0x001503a0\nprogramming firmware file: programmer_firmware.bin\nreinitialise onchip uart to 500000\nwaiting for firmware to run\nflash ID 0xc21320c2\nflash size is 4 Mb\n\nbegin read operation\n\n0x000000:[rrrrrrrr] 0x008000:[rrrrrrrr] 0x010000:[rrrrrrrr] 0x018000:[rrrrrrrr]\n0x020000:[rrrrrrrr] 0x028000:[rrrrrrrr] 0x030000:[rrrrrrrr] 0x038000:[rrrrrrrr]\n0x040000:[rrrrrrrr] 0x048000:[rrrrrrrr] 0x050000:[rrrrrrrr] 0x058000:[rrrrrrrr]\n0x060000:[rrrrrrrr] 0x068000:[rrrrrrrr] 0x070000:[rrrrrrrr] 0x078000:[rrrrrrrr]\noutput file format not specified, assuming 'raw'\n</code></pre>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#troubleshooting","title":"Troubleshooting","text":"<p>Here's what it looks like if your firmware versions are mismatched:</p> <pre><code>$ winc_programmer_uart.exe -p COM4 -d winc1500 -r -pfw ..\\programmer_firmware\\release3A0\\programmer_firmware.bin -o atwinc1500-original.bin\nWINC Programming Tool 1.0.3 [r708] (Jul 28 2020)\nCopyright (C) Microchip Technology Inc. 2020\nhardware WINC serial bridge found\nchip ID is 0x001503a0\nprogramming firmware file: ..\\programmer_firmware\\release3A0\\programmer_firmware.bin\nreinitialise onchip uart to 500000\nwaiting for firmware to runerror(uart_read:61): incomplete read from UART\nerror: failed to receive read register response\nerror: failed to initialise programming firmware '..\\programmer_firmware\\release3A0\\programmer_firmware.bin' on device\n</code></pre>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#firmware-analysis","title":"Firmware Analysis","text":"<p>Now that we've got a fresh binary, let's see what we can do.</p> <p>Using the <code>tls_cert_flash_tool.exe</code> mentioned in Understanding The ATWINC1500 ModuleTLS Server Store:</p>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#tls-server-store_1","title":"TLS Server Store","text":"<pre><code># Summary of TLS Store\n$ tls_cert_flash_tool.exe read -fwimg atwinc1500-adafruit.bin -ecdsa -rsa -dir\n\n******************************************\n*   WINC1500 TLS Certificate Flash Tool  *\n******************************************\n&lt;RSA CERTIFICATE CHAIN FILE LIST&gt;\n\nPRIV_00ddb578c5a531f273                          1208 PRIVATE KEY\nCERT_00ddb578c5a531f273                           950 CERTIFICATE  *.winc.atmel.com\nCERT_00def74d6dfa50e85c                          1003 CERTIFICATE  WINCRootCA\n\n&lt;ECDSA CERTIFICATE CHAIN FILE LIST&gt;\n\nCERT_00f4bb2e4a6fd5ae51                           579 CERTIFICATE  *.winc.atmel.com\nCERT_00ddefc26b1df1c50d                           754 CERTIFICATE  AtmelEccCA\nCERT_00def74d6dfa50e85c                          1003 CERTIFICATE  WINCRootCA\n\n*=*=* X509 *=*=*\n        Subject &lt;*.winc.atmel.com&gt;\n        Issuer  &lt;WINCRootCA&gt;\n        &lt;2016-06-12 12:29:03&gt; to &lt;2021-12-03 12:29:03&gt;\n\n*=*=* X509 *=*=*\n        Subject &lt;*.winc.atmel.com&gt;\n        Issuer  &lt;AtmelEccCA&gt;\n        &lt;2016-07-18 13:31:13&gt; to &lt;2023-05-23 13:31:13&gt;\n</code></pre> <pre><code># Extract TLS Private Key\n$ tls_cert_flash_tool.exe read -fwimg atwinc1500-adafruit.bin -rsa -privkey\n\n******************************************\n*   WINC1500 TLS Certificate Flash Tool  *\n******************************************\nPrivate-Key: (2048 bit)\nmodulus (N):\n        AD 62 49 6E 87 72 FA D4 E0 1A 48 1C B8 B4 5E D1\n        9D B9 EC A4 99 86 6D 23 9E 10 BD 8D D3 07 FA 58\n63 D1 E9 FB 8D A5 9B 61 83 68 4D 17 C8 35 E1 85\n89 85 6F 29 91 CC AC A4 B1 3C E2 F4 E3 81 9E 30\n8A 86 11 FF D4 97 C0 DD B1 14 64 44 14 C9 F9 BA\n        59 1B 8F 82 07 23 D0 00 C1 AD 95 BC 28 39 19 87\nFB F3 10 5E 25 EF FB 8A 54 CA 96 1F A2 03 1C 90\nDB 51 44 93 C9 11 EF 3F 93 34 66 36 6B 48 44 61\n14 0A FE 15 AB 53 74 0B F7 30 F8 7B 3E 55 98 32\n10 94 53 FA BC C4 C2 0D CE 91 F5 3D 50 3B 69 A8\n        3A AF 03 09 C4 A4 74 4C 62 49 98 C9 FC 1E 9B 7F\n        A7 9B 2D A4 BF C2 AE 42 D0 E7 09 27 D2 E4 CD DC\n        D0 88 3B 43 20 F2 15 0D 32 92 8E 4D 9E C6 E9 C6\n        DE 7D 65 01 22 E1 B7 60 6F C0 27 11 7C F7 FA FD\n        7C FE 5B 23 A7 00 56 DF 99 ED 1A 44 CF D6 BA F9\n        8A 09 6A D3 54 81 55 25 86 7D C0 7C 68 CC FF 31\npublicExponent (e):\n        01 00 01\nprivateExponent (d):\n        3D 37 5D 9B E3 C0 E9 E4 ED 36 FA 4D 01 BD D5 58\n87 2A D4 ED 8C B3 14 A7 A5 B0 5D 6C CC 9C 9D 7C\n        45 CA 20 A5 CB 6E 34 3D 2A AB 51 C4 DA D0 83 4E\n        A5 AE 72 00 28 55 2E 83 7B 7C 76 D9 65 D6 26 E7\n        16 91 9D 9B 49 11 47 6C 3E 90 67 92 4E 10 BD D6\n        58 8D CD 8E 68 3C F1 BC C2 A5 2A 1F E3 C7 BD 46\nF0 E2 F1 DD 7B E1 8E 5B 59 F2 A9 2C 84 04 3B 3A\n        BD E4 A4 A4 D5 32 3A D9 A4 7C B4 B5 F4 0C F0 EF\n        0C 86 C6 B1 6C EA 63 D5 79 D5 20 37 C0 8E AF 0E\n        20 E9 6B 91 D4 FB 15 B8 FF E4 1E 80 20 52 3A 7F\n        C2 83 92 22 AF AC 16 9D 93 0D E6 56 3A 84 E8 B6\n        77 56 77 AF 23 E3 68 DC 91 14 C8 FC 61 47 57 8C\n        7D B6 DA 19 13 2A D2 DE D7 E5 BD 59 70 86 AF 39\nAD CB 29 75 20 CB 36 93 D3 57 34 74 E0 26 B4 B7\n        9B 37 49 F8 0E 11 FF 42 72 9B 93 5B 78 BA A8 55\n4B 5F 78 E9 99 DE ED 9C 49 28 FC AC 9B B4 E4 C1\nprim1 (p):\n        E1 C9 49 53 EB 34 15 5B 0D E5 01 38 49 4E 0B 40\n00 C6 AF 4C C1 EB 59 ED 07 69 5D 40 D7 82 14 21\n3E 39 9F 94 F1 B8 FB EA B9 91 FB 7C F0 0D 96 F4\n        F5 30 81 D5 65 4D 7C 5A 19 35 C4 2D 04 C3 22 F1\n        73 12 4F 68 97 7A 66 71 D7 68 E5 22 41 B3 AF C4\n        C4 46 49 40 D5 7A FC EC F4 8D 02 EE 95 C4 01 F2\n        C5 E7 13 DD 62 D3 FF 46 18 BA 05 24 5C D7 3E 1C\n        C7 7B 84 66 D8 DC 0C 10 AE FD 8B 53 FF AE 51 19\nprime2 (q):\n        C4 95 DD 3F 4D E1 D3 75 1D CC 3C 82 82 40 4C C7\n        66 A5 71 A9 A5 DE F1 1A ED FA B5 6F 4A 92 E9 8C\n        05 1B 4A 67 D3 8A B7 53 6C 83 DD A5 31 34 92 D0\n        AF 3D FF 06 00 45 C4 A8 12 DF E1 29 8E 93 09 B9\n        99 25 12 1F 94 F1 09 B8 14 67 9D 35 2A D2 AF 39\n05 92 88 F4 DC D3 5E 55 DA 99 C2 0E 8F C2 DC 3D\n        6B 98 22 40 80 72 6D 1F D9 E2 87 6F 60 33 16 6A\n        08 B3 2E 61 63 7C EE 69 BF 06 71 9D 1A DF 69 D9\nexponent1 (dP):\n        12 0E 5F CF D7 3A 66 0E CF 10 A6 45 53 0F 6B B4\n        E5 9A FD FF DC 6E 2E D5 D6 C6 E5 4F 3F 2C C6 E1\n        55 B1 94 02 7C 46 37 D7 30 99 ED 0B B3 C2 D2 74\nAA 7B 03 97 06 2F E9 26 E7 67 36 56 07 50 77 A5\n        E9 76 E8 64 CB E0 5C FA F3 A8 0E D2 EB 80 2C 29\n47 2C FB C4 B4 8D CE 56 40 C4 5A 1C AC 5B 6D 70\n75 C5 22 00 8D 5B B8 C9 69 46 CF 0C 76 64 3C 32\n5E FD 90 BC 0C D1 A4 21 5D 6D 27 4C 43 61 34 59\nexponent2 (dQ):\n        4F 8B 2C 48 EF 24 8F 41 76 5B 2B A8 CB 37 65 59\nD1 C8 E3 E2 F7 40 EC 62 2F 25 20 C0 F5 75 D8 96\n55 82 A3 6A BB 88 07 81 F4 08 AF 68 A6 2E 55 B1\n        A7 16 F8 D7 DE C8 5C 38 7D DA A4 EB 01 CB B1 45\nAE 17 F7 EB 5B 82 E4 A1 DD 6F C7 86 B9 DB 22 17\n7A 8F BE 67 05 EB 68 E2 68 5F 8A CC 05 93 9D 36\n25 11 1B DA E9 9E 63 55 5D FE 71 3A B9 BC 32 37\n99 69 97 3C C4 DA CA 45 73 8C 11 F0 B5 EC EC 91\ncoefficient(QInv):\n        62 4F E3 8A 73 BD 03 DC 17 DD 17 87 DB 1C EA 88\n5E C2 F7 7D 3F 1F 47 52 B2 F5 43 92 A8 D0 9D D0\n        3E 7E 98 A3 B1 DC 84 90 01 B1 16 D6 0D 05 77 03\nEA 0D 10 68 DC 74 D7 82 90 05 7C 80 26 8D C3 2D\n        7D 96 65 4C 29 6B 1A A2 F7 59 24 40 58 12 77 19\n6C 37 FD 94 23 A9 C4 D3 82 67 F4 13 33 09 29 B0\n        88 D2 80 CC A5 3F C5 E7 53 A6 EA 87 26 0A 42 0E\n        35 97 07 88 66 4C BA 1A B1 08 92 97 49 74 3C D0\n\n*=*=* X509 *=*=*\n        Subject &lt;*.winc.atmel.com&gt;\n        Issuer  &lt;WINCRootCA&gt;\n        &lt;2016-06-12 12:29:03&gt; to &lt;2021-12-03 12:29:03&gt;\n</code></pre> <pre><code># Extract TLS Certificate(s)\ntls_cert_flash_tool.exe read -fwimg atwinc1500-adafruit.bin -ecdsa -rsa -all -out output\n\n******************************************\n*   WINC1500 TLS Certificate Flash Tool  *\n******************************************\nPress any key to continue . . .\n\n$ ls output\nAtmelEccCA.cer  ECDSA_winc.atmel.com.cer  RSA_winc.atmel.com.cer  WINCRootCA.cer\n</code></pre>","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#further-analysis","title":"Further Analysis","text":"ImHex Patterns Root Cert Store Root Cert Store TLS Store TLS Store","tags":["microchip","firmware","analysis","uC"]},{"location":"projects/hunter-hacking/understanding-the-atwinc1500-module/index.html#graveyard","title":"Graveyard","text":"<p>The <code>winc_programmer_uart.exe</code> comes as part of the Atmel Studio 7.0 \"WINC1500 Firmware Update Project\":</p> <pre><code>[I] \u276f tree -L 6 -a|more\n.\n\u251c\u2500\u2500 WINC1500_FIRMWARE_UPDATE_PROJECT1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n|       ...\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 firmware\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 Tools\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 flash-tools\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 image_tool_linux.tar.gz\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 image_tool_windows.zip\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 winc_programmer_linux.tar.gz\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 winc_programmer_windows.zip\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 boot_firmware\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 release3A0\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 boot_firmware.bin\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 downloader_firmware\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 release3A0\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 downloader_firmware.bin\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 firmware\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 aardvark.dll\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 flash_image.config\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 image_tool.exe\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 m2m_image_3A0.aoi\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 m2m_image_3A0.bin\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 wifi_v111\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ASIC_3A0\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 winc_programmer_i2c.exe\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 winc_programmer_uart.exe\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ota_firmware\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 m2m_ota_3a0.bin\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 programmer_firmware\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 release3A0\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 programmer_firmware.bin\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 programmer_release_text.bin\n...\n</code></pre> <p></p> <code>#microchip</code> <code>#firmware</code> <code>#analysis</code> <code>#uC</code>","tags":["microchip","firmware","analysis","uC"]},{"location":"assets/templates/blog-entry/index.html","title":"Blog entry","text":"<ul> <li>wip description:  date: {{date}}</li> </ul>"},{"location":"tags/index.html","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags/index.html#analysis","title":"analysis","text":"<ul> <li>Learning How To MitM An ATWINC1500</li> <li>MitM A Hunter Pro HC</li> <li>Understanding The ATWINC1500 Module</li> </ul>"},{"location":"tags/index.html#arduino","title":"arduino","text":"<ul> <li>ESP32</li> <li>Black Pill</li> <li>ITead Maple</li> <li>Super Blue Pill</li> </ul>"},{"location":"tags/index.html#datascience","title":"datascience","text":"<ul> <li>How To Size A Solar Battery Install</li> </ul>"},{"location":"tags/index.html#dll","title":"dll","text":"<ul> <li>Creating A DLL With Rust</li> <li>Creating A Window With Rust</li> <li>Injecting DLLs With Rust</li> <li>Production Ready DLL Injection</li> </ul>"},{"location":"tags/index.html#esp32","title":"esp32","text":"<ul> <li>ESP32</li> </ul>"},{"location":"tags/index.html#esp8266","title":"esp8266","text":"<ul> <li>Index</li> <li>ESP-01</li> <li>Wemos Mini</li> </ul>"},{"location":"tags/index.html#firmware","title":"firmware","text":"<ul> <li>Learning How To MitM An ATWINC1500</li> <li>MitM A Hunter Pro HC</li> <li>Understanding The ATWINC1500 Module</li> </ul>"},{"location":"tags/index.html#github","title":"github","text":"<ul> <li>How I Setup This Blog</li> </ul>"},{"location":"tags/index.html#howto","title":"howto","text":"<ul> <li>Creating A DLL With Rust</li> <li>Creating A Window With Rust</li> <li>Injecting DLLs With Rust</li> <li>Production Ready DLL Injection</li> </ul>"},{"location":"tags/index.html#hunter","title":"hunter","text":"<ul> <li>Taking Apart A Hunter Pro HC Controller</li> </ul>"},{"location":"tags/index.html#iot","title":"iot","text":"<ul> <li>How To Quickly Setup A Wireless MitM Proxy</li> </ul>"},{"location":"tags/index.html#irrigation","title":"irrigation","text":"<ul> <li>Taking Apart A Hunter Pro HC Controller</li> </ul>"},{"location":"tags/index.html#kali","title":"kali","text":"<ul> <li>How To Quickly Setup A Wireless MitM Proxy</li> </ul>"},{"location":"tags/index.html#microchip","title":"microchip","text":"<ul> <li>Learning How To MitM An ATWINC1500</li> <li>MitM A Hunter Pro HC</li> <li>Understanding The ATWINC1500 Module</li> </ul>"},{"location":"tags/index.html#mitm","title":"mitm","text":"<ul> <li>How To Quickly Setup A Wireless MitM Proxy</li> <li>Learning How To MitM An ATWINC1500</li> </ul>"},{"location":"tags/index.html#mkdocs","title":"mkdocs","text":"<ul> <li>Setting Up A MkDocs Plugin Development Environment</li> <li>How I Setup This Blog</li> </ul>"},{"location":"tags/index.html#obsidian","title":"obsidian","text":"<ul> <li>How I Setup This Blog</li> </ul>"},{"location":"tags/index.html#plugin","title":"plugin","text":"<ul> <li>Setting Up A MkDocs Plugin Development Environment</li> </ul>"},{"location":"tags/index.html#powertoys","title":"powertoys","text":"<ul> <li>Fancy Zones   Internals</li> <li>Fancy Zones   Overview</li> </ul>"},{"location":"tags/index.html#programming","title":"programming","text":"<ul> <li>Creating A DLL With Rust</li> <li>Creating A Window With Rust</li> <li>Injecting DLLs With Rust</li> <li>Production Ready DLL Injection</li> </ul>"},{"location":"tags/index.html#rust","title":"rust","text":"<ul> <li>Creating A DLL With Rust</li> <li>Creating A Window With Rust</li> <li>Injecting DLLs With Rust</li> <li>Production Ready DLL Injection</li> </ul>"},{"location":"tags/index.html#solar","title":"solar","text":"<ul> <li>How To Size A Solar Battery Install</li> </ul>"},{"location":"tags/index.html#sprinker","title":"sprinker","text":"<ul> <li>Taking Apart A Hunter Pro HC Controller</li> </ul>"},{"location":"tags/index.html#stm32","title":"stm32","text":"<ul> <li>Black Pill</li> <li>ITead Maple</li> <li>Super Blue Pill</li> </ul>"},{"location":"tags/index.html#teardown","title":"teardown","text":"<ul> <li>Taking Apart A Hunter Pro HC Controller</li> </ul>"},{"location":"tags/index.html#uc","title":"uC","text":"<ul> <li>Learning How To MitM An ATWINC1500</li> <li>MitM A Hunter Pro HC</li> <li>Taking Apart A Hunter Pro HC Controller</li> <li>Understanding The ATWINC1500 Module</li> </ul>"},{"location":"tags/index.html#uc_1","title":"uc","text":"<ul> <li>ESP32</li> <li>Index</li> <li>ESP-01</li> <li>Wemos Mini</li> <li>Black Pill</li> <li>ITead Maple</li> <li>Super Blue Pill</li> </ul>"},{"location":"tags/index.html#vscode","title":"vscode","text":"<ul> <li>Setting Up A MkDocs Plugin Development Environment</li> </ul>"},{"location":"tags/index.html#win32","title":"win32","text":"<ul> <li>Creating A Window With Rust</li> </ul>"},{"location":"tags/index.html#windows","title":"windows","text":"<ul> <li>Fancy Zones   Internals</li> <li>Fancy Zones   Overview</li> <li>Creating A DLL With Rust</li> <li>Creating A Window With Rust</li> <li>Injecting DLLs With Rust</li> <li>Production Ready DLL Injection</li> </ul>"},{"location":"tags/index.html#windows-rs","title":"windows-rs","text":"<ul> <li>Creating A Window With Rust</li> </ul>"},{"location":"tags/index.html#wip","title":"wip","text":"<ul> <li>Black Magic Probe</li> <li>Segger J-Link</li> <li>Adafruit Feather M0 WiFi</li> <li>Raspberry Pi</li> <li>SerialMoose Serial Port Sniffer</li> <li>My Smart Home Devices</li> <li>Samsung Refrigerator Integration</li> </ul>"}]}